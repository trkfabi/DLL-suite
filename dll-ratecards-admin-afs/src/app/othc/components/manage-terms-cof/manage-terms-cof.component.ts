import { Component, OnDestroy, OnInit } from '@angular/core';
import { FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import {
	AuthService,
	BusyService,
	DataManagerService,
	DEFAULT_PERMISSION,
	doLog,
	ErrorService,
	LayoutService,
	RateCardsWebService,
} from '@core/index';
import { DialogRef, DialogService } from '@progress/kendo-angular-dialog';
import { GridModule } from '@progress/kendo-angular-grid';
import { TermsDialogComponent } from '@shared/components/shared';
import { IManageTermsCOF } from '@shared/interfaces/manage-terms-cof.interface';
import * as _ from 'lodash';
import { Subscription } from 'rxjs';

const LOG_TAG = '[components/ManageTermsCOFComponent]';

@Component({
	selector: 'app-manage-terms-cof',
	templateUrl: './manage-terms-cof.component.html',
	styleUrls: ['./manage-terms-cof.component.scss'],
})
export class ManageTermsCofComponent implements OnInit, OnDestroy {
	/**
	 * @property {Object} dialogRefComponent stores the instance reference from the dialog component generated by the `DialogService`
	 */
	public dialogRefComponent;
	/**
	 * @property {Object} dialogRef stores the reference to the dialog generated by the `DialogService`
	 */
	public dialogRef: DialogRef;
	/**
	 * @property {string} action stores the action to execute on submit dialog.
	 */
	public dialogAction;
	/**
	 * @property {Boolean} buttonAction saves the button message on submit
	 */
	public buttonAction;
	/**
	 * @property {Boolean} isDisabled flag is is disabled
	 */
	public isDisabled: boolean;
	/**
	 * @property {Object} versionSelected Stores the current version data.
	 */
	public versionSelected;
	/**
	 * @property {Object} versionSelectedSubscription
	 * @private
	 */
	private versionSelectedSubscription: Subscription;
	/**
	 * @property {Object[]} gridData stores the terms from catalogue data.
	 */
	public gridData = [];
	/**
	 * @property {string} validPath Receive Url with user permission
	 */
	public validPath: string;
	/**
	 * @property {Boolean} edited flag is is edit
	 */
	private edited: boolean = false;

	constructor(
		private _dialogService: DialogService,
		private _dataManagerService: DataManagerService,
		private _busyService$: BusyService,
		private _errorService: ErrorService,
		private _authService: AuthService,
		private _router: Router,
		private _formBuilder: FormBuilder,
		private _rateCardsWebService: RateCardsWebService,
		private _layoutService: LayoutService,
		private _dataManager: DataManagerService
	) {
		const userPermission = this._authService.getUserPermissions() || DEFAULT_PERMISSION;
		this.validPath = `/${userPermission}/dashboard`;
	}
	/**
	 * @method ngOnInit
	 * Respond when initialize app
	 * @return {void}
	 */
	public ngOnInit(): void {
		this.initialize();
	}
	/**
	 * @method ngOnDestroy
	 * Respond when destroy component
	 * @return {void}
	 */
	public ngOnDestroy() {
		this.versionSelectedSubscription.unsubscribe();
	}
	/**
	 * @method initialize
	 * Initialize loader display and load version selected
	 * @return {void}
	 */
	public initialize(): void {
		this.isDisabled = true;
		this.showLoader();
		this._layoutService.setNavControlsReadOnly(true);
		this.versionSelectedSubscription = this._dataManagerService.versionSelected$.subscribe((versionSelected) => {
			if (versionSelected && !this.versionSelected) {
				this.loadVersionSelected(versionSelected);
			}
		});
	}
	/**
	 * @method loadVersionSelected
	 * Handles the load of terms at the begining to show terms and cofs in version selected.
	 * @property {Object} versionSelected
	 * @return {void}
	 */
	public loadVersionSelected(versionSelected): void {
		doLog && console.log(LOG_TAG, '- loadVersionSelected', versionSelected);
		const { cofs, terms } = versionSelected || {};
		this.versionSelected = versionSelected;
		if (cofs && terms) {
			this.updateMangeTermsCof(terms, cofs);
		}
		if (this.versionSelected) {
			_.defer(() => {
				this.isDisabled = false;
				this.hideLoader();
			});
		}
	}
	/**
	 * @method updateMangeTermsCof
	 * Update gridData with terms and cofs values
	 * @param {Object[]} terms Receives terms values
	 * @param {Object[]} cofs Receives cofs values
	 * @return {void}
	 */
	public updateMangeTermsCof(terms = [], cofs = []): void {
		doLog && console.log(LOG_TAG, 'updateMangeTermsCof', terms, cofs);
		this.gridData = _.chain(terms)
			.map((term, index) => {
				const cof = cofs[index].value * 100;
				return { term: Number(term), cof };
			})
			.value();
	}
	/**
	 * @method onCellClickEventHandler
	 * Executes the click handlter to create the form group to edit cell data.
	 * @param {Object} _evt The event handler to catch the cell data.
	 * @param {Object} _evt.sender The sender property of the cell to call editCell method.
	 * @param {Number} _evt.rowIndex The current row index of cell selected..
	 * @param {Number} _evt.columnIndex The current column index of cell selected.
	 * @param {Object} _evt.dataItem The data of the current cell clicked.
	 * @return {void}
	 */
	public onCellClickEventHandler(_evt) {
		doLog && console.log(LOG_TAG, 'onCellClickEventHandler', _evt);
		if (!_evt.isEdited) {
			const cellData: any = {
				currentIndex: _evt.column.field,
				dataItem: _evt.dataItem,
				gridData: this.gridData,
			};
			if (cellData.currentIndex === 'term') {
				return;
			}
			_evt.sender.editCell(_evt.rowIndex, _evt.columnIndex, this.createFormGroup(cellData));
		}
	}
	/**
	 * @method cellCloseHandler
	 * Event when cell from grid is colse
	 * @param {Object} _evt The event handler to catch the args to process the request.
	 * @param {Object} _evt.formGroup The form group object with all the current values expected to update.
	 * @param {Object} _evt.dataItem The data of the current cell clicked.
	 * Executes the close handler to set the new values to the current dataItem.
	 * @return {void}
	 */
	public onCellCloseHandler(_evt) {
		doLog && console.log(LOG_TAG, 'onCellCloseHandler', _evt);
		const { formGroup, dataItem } = _evt || {};
		if (!formGroup || (formGroup && !formGroup.valid)) {
			return;
		}

		this.saveItemCof(formGroup, dataItem);
	}
	/**
	 * @method saveItemCof
	 * Save item COF in gridData variable
	 * @param {FormGroup}  formGroup
	 * @param {Object} dataItem
	 * @return {void}
	 */
	public saveItemCof(formGroup, dataItem): void {
		const field = 'term' + dataItem.term;
		const value = formGroup.controls[field].value || 0;
		const index = _.findIndex(this.gridData, { term: dataItem.term });
		this.gridData[index].cof = value;
		this.edited = true;
	}
	/**
	 * @method createFormGroup
	 * Generates the inputs to edit the cell via formBuilder.
	 * @param {Object} _dataItem The data of the current cell to edit.
	 * @param {Object} _gridData
	 * @return {void}
	 */
	private createFormGroup(_cellData): FormGroup {
		const formFields = {};
		_.each(_cellData.gridData, (_term, _key) => {
			_.extend(formFields, {
				['term' + _term.term]: new FormControl(parseFloat(_cellData.dataItem.cof), [Validators.maxLength(3), Validators.max(100)]),
			});
		});
		return this._formBuilder.group(formFields);
	}
	/**
	 * @method hideLoader
	 * Hides the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public hideLoader() {
		this._busyService$.hideLoading();
	}
	/**
	 * @method showLoader
	 * Displays the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public showLoader() {
		this._busyService$.showLoading();
	}
	/**
	 * @method onDoneButtonClick
	 * Submit terms and cofs to webservice in order to store them into the current version.
	 * @param _evt The done button click event.
	 * @return {void}
	 */
	public async onDoneButtonClick(_evt) {
		doLog && console.log(LOG_TAG, 'onDoneButtonClick', _evt);
		this.showLoader();
		if (this.edited) {
			try {
				const version = this.getVersionData();
				await this._dataManagerService.updateTermsAndCofs(version);
				const { id = '' } = this._dataManagerService.versionSelected || {};
				await this._dataManagerService.fetchVersionSelected(id);
				this._router.navigate([this.validPath]);
			} catch (_error) {
				throw new Error(_error);
			}
		}
		this._router.navigate([this.validPath]);
	}

	/**
	 * @method getVersionData
	 * Return version data with manage terms and COF
	 * @return {IManageTermsCOF}
	 */
	public getVersionData(): IManageTermsCOF {
		return {
			id: this.versionSelected.id,
			terms: _.map(this.gridData, (item) => item.term.toString()),
			cofs: _.map(this.gridData, (item) => ({ term: item.term.toString(), value: item.cof / 100 || 0 })),
		};
	}
	/**
	 * @method onRemoveTermButtonClick
	 * On Remove term click event, handles the event to remove term
	 * @param _evt The click event of remove term button.
	 * @return {void}
	 */
	public onRemoveTermButtonClick(term: number, _templateActions): void {
		doLog && console.log(LOG_TAG, 'onRemoveTermButtonClick', term);
		const _params = { item: { name: term } };
		if (this.gridData.length === 1) {
			this.displayDeleteTermDialogNoRemove(_templateActions, _params);
			return;
		}
		this.displayDeleteTermDialog(_templateActions, _params);
	}
	/**
	 * @method displayDeleteTermDialog
	 * Display delete term dialog
	 * @param {object} _templateActions Receives template object actions.
	 * @param {object} _params Receives params object.
	 * @return {void}
	 */
	public displayDeleteTermDialog(_templateActions, _params): void {
		const month = +_params.item.name > 1 ? 's' : '';
		this.dialogRef = this._dialogService.open({
			title: 'Delete Term',
			content: TermsDialogComponent,
			actions: _templateActions,
			height: 212,
			width: 386,
		});
		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.item = _params.item;
		this.dialogRefComponent.isDelete = true;
		this.dialogRefComponent.removeMessage = `${_params.item.name} Month${month}`;
		this.dialogRefComponent.origin = 'COF';
		this.buttonAction = 'Delete';
		this.dialogAction = 'delete';
	}
	/**
	 * @method displayDeleteTermDialogNoRemove
	 * Display delete term that can`t remove
	 * @param {object} _templateActions Receives template object actions.
	 * @param {object} _params Receives params object.
	 * @return {void}
	 */
	public displayDeleteTermDialogNoRemove(_templateActions, _params): void {
		this.dialogRef = this._dialogService.open({
			title: 'Delete Term',
			content: TermsDialogComponent,
			actions: _templateActions,
		});
		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.item = _params.item;
		this.dialogRefComponent.isDelete = true;
		this.buttonAction = 'OK';
		this.dialogAction = null;
	}
	/**
	 * @method handleDialogSubmitButtonClick
	 * Handle submission from dialogs.
	 * @return {void}
	 */
	public handleDialogSubmitButtonClick(_evt) {
		doLog && console.log(LOG_TAG, 'handleDialogSubmitButtonClick', _evt);
		this.validateSubmitAction(this.dialogAction);
	}
	/**
	 * @method onAddTermButtonClick
	 * On Add Term button click event, handles the event to add term
	 * @param _params {Object} stores the item data to add.
	 * @return {void}
	 */
	public onAddTermButtonClick(_evt, _params, _templateActions) {
		const newTerm = {
			name: null,
		};
		this.dialogRef = this._dialogService.open({
			title: 'New Term',
			content: TermsDialogComponent,
			actions: _templateActions,
			width: 295.5,
			height: 171.5,
		});
		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.item = newTerm;
		this.dialogRefComponent.terms = this.gridData;
		this.buttonAction = 'Save';
		this.dialogAction = 'add';
	}

	/**
	 * @method handleDialogCloseButtonClick
	 * Handle cancellation
	 * @return {void}
	 */
	public handleDialogCloseButtonClick(_evt) {
		this.dialogRef.close();
	}
	/**
	 * @method validateSubmitAction
	 * Validate dialog actions to apply depend input type
	 * @param {string} type Receives type action.
	 * @return {void}
	 */
	public validateSubmitAction(type: string): void {
		switch (type) {
			case 'add':
				if (!this.isValidEntry(this.dialogRefComponent.item)) {
					this.dialogRefComponent.errorMessage = 'Introduce a valid entry between 1 and 99.';
					this.dialogRefComponent.showErrorMessage = true;
					return;
				}
				if (_.find(this.gridData, { term: this.dialogRefComponent.item.name })) {
					this.dialogRefComponent.errorMessage = 'This Term already exists.';
					this.dialogRefComponent.showErrorMessage = true;
					return;
				}
				this.gridData.push({ term: this.dialogRefComponent.item.name, cof: 0 });
				this.reOrder();
				break;
			case 'delete':
				this.gridData = _.remove(this.gridData, (item) => item.term !== this.dialogRefComponent.item.name);
				this.reOrder();
				break;
			default:
				this.dialogRef.close();
				break;
		}
	}
	/**
	 * @method isValidEntry
	 * Validates if term value is acceptable based on business rules.
	 * @param {Object} _value The term object to validate.
	 * @return {Boolean}
	 */
	public isValidEntry(_value) {
		doLog && console.log(LOG_TAG, 'isValidEntry', _value);
		return _value.name !== null && _value.name > 0 && _value.name <= 99;
	}
	/**
	 * @method reOrder
	 * Reorder gridData in asc and close dialog
	 * @return {void}
	 */
	public reOrder() {
		this.gridData = _.orderBy(this.gridData, ['term', 'asc']);
		this.edited = true;
		this.dialogRef.close();
	}
}
