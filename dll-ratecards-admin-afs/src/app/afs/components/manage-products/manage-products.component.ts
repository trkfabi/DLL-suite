import { splitClasses } from '@angular/compiler';
import { AfterContentInit, Component, Input, OnDestroy, OnInit, QueryList, TemplateRef, ViewChild, ViewChildren } from '@angular/core';
import { Router, VERSION } from '@angular/router';
import { AppSettings, AuthService, BusyService, DEFAULT_PERMISSION, doLog, LayoutService, ToastService } from '@core/index';
import { DataManagerService } from '@core/services/data-manager.service';
import { DialogCloseResult, DialogRef, DialogService } from '@progress/kendo-angular-dialog';
import { DataEvent, DragEndEvent, SortableComponent } from '@progress/kendo-angular-sortable';
import { GridComponent } from '@shared/components';
import { ProductCategoriesDialogComponent } from '@shared/components/shared/product-categories-dialog/product-categories-dialog.component';
import { ProductDialogComponent } from '@shared/components/shared/product-dialog/product-dialog.component';
import { TermsDialogComponent } from '@shared/components/shared/terms-dialog/terms-dialog.component';
import { IProductCategories } from '@shared/models/product-categories.model';
import { IProduct } from '@shared/models/product.model';
import { ITerm } from '@shared/models/terms.model';
import * as _ from 'lodash';
import * as moment from 'moment';
import { Observable, Subscription } from 'rxjs';

const LOG_TAG = '[components/manage-products.component]';

@Component({
	selector: 'app-manage-products',
	templateUrl: './manage-products.component.html',
	styleUrls: ['./manage-products.component.scss'],
})
export class ManageProductsComponent implements AfterContentInit, OnInit, OnDestroy {
	/**
	 * @property {Object[]} products Stores product list from webservices.
	 */
	public products: any[];

	/**
	 * @property {Object[]} productCategories Stores product categories list from webservices.
	 */
	public productCategories;

	/**
	 * @property {Object[]} productsFiltered Stores product filtered by category selected.
	 */
	public productsFiltered: any[];

	/**
	 * @property {Boolean} categorySelected Status of category selected
	 */
	public categorySelected: boolean | any = false;

	/**
	 * @property {String} buttonAction Button action text to display on dialogs.
	 */
	public buttonAction: string;

	/**
	 * @property {Object} tempValue Temporary value to edit.
	 */
	public tempValue;

	/**
	 * @property {String} removeMessage Stores remove message on remove event.
	 */
	public removeMessage;

	/**
	 * @property {Boolean} isDelete Status to enable delete messages on dialog.
	 */
	public isDelete: boolean;

	/**
	 * @property {String} action Action to execute on dialog events submission.
	 */
	public action: string;

	/**
	 * @property {Object[]} catalogueData  Receives the `catalogueData` from Webservices.
	 */
	public catalogueData;

	/**
	 * @property {String} rateType displays the rate type enabled on product.
	 */
	public rateType: string;

	/**
	 * @property {String} versionId Stores the current version Id selected.
	 */
	private versionId;

	/**
	 * @property {Object} dataLoaded Stores the current version data.
	 */
	private dataLoaded;

	/**
	 * @property {Object} versionSelected Stores the current version data.
	 */
	public versionSelected;

	/**
	 * @property {Object} tempCategorySelected Temporary category selected
	 */
	private tempCategorySelected;

	/**
	 * @property {Object} dialogRef stores the reference to the dialog generated by the `DialogService`
	 * @private
	 */
	public dialogRef: DialogRef;

	/**
	 * @property {Object} dialogRefComponent stores the instance reference from the dialog component generated by the `DialogService`
	 */
	public dialogRefComponent;

	/**
	 * @property {Object} dialogRefUnexpectedError stores the reference to the dialog Unexpected Error generated by the `DialogService`
	 * @private
	 */
	private dialogRefUnexpectedError: DialogRef;

	/**
	 * @property {@ViewChild} dialogActionsUnexpectedError stores the reference template for Unexpected Error dialog actions
	 */
	@ViewChild('dialogActionsUnexpectedError') private dialogActionsUnexpectedErrorTemplateref: TemplateRef<any>;

	/**
	 * @property {Object} versionSelectedSubscription
	 * @private
	 */
	private versionSelectedSubscription: Subscription;
	/**
	 * @property {Boolean} isRendered flag if is rendered
	 */
	private isRendered: boolean;
	/**
	 * @property {Boolean} isRemoving flag if is removed
	 */
	public isRemoving: boolean;
	/**
	 * @property {Number} lastIndex last index number
	 */
	public lastIndex: number;

	/**
	 * @property {Boolean} Flag to determine if batch processing should take place after cancelling version modal
	 */
	public sortedIndex;

	/**
	 * @property {string} validPath Receive Url with user permission
	 */
	public validPath: string;

	constructor(
		private _appSettings: AppSettings,
		public _dialogService: DialogService,
		private _router: Router,
		public _dataManagerService: DataManagerService,
		private _busyService$: BusyService,
		private _layoutService: LayoutService,
		private _toast: ToastService,
		private _authService: AuthService
	) {
		const userPermission = this._authService.getUserPermissions() || DEFAULT_PERMISSION;
		this.validPath = `/${userPermission}/dashboard`;
	}

	public ngOnInit() {
		this.productsFiltered = [];
		this.showLoader();
		this._layoutService.setNavControlsVisibility(false);
		this.sortedIndex = false;
	}

	public ngAfterContentInit() {
		this.versionSelectedSubscription = this._dataManagerService.versionSelected$.subscribe((_versionSelected) => {
			this.loadVersionSelected(_versionSelected);
		});

		if (!this.versionSelected && this.isRendered) {
			this.hideLoader();
		}
	}

	public ngOnDestroy() {
		this.versionSelectedSubscription.unsubscribe();
	}
	/**
	 * @method onConfirmRemoveItemButtonClick
	 * Confirm to remove the item from the array updating the status to -1.
	 * @return {void}
	 */
	public onConfirmRemoveItemButtonClick(_evt, _params, dialog) {
		doLog && console.log(LOG_TAG, '-onConfirmRemoveItemButtonClick', _evt);
	}

	/**
	 * @method onCancelRemoveItemButtonClick
	 * Cancel the remove item request.
	 * @param {Object} _evt the `CancelRemoveItemButton` click event.
	 * @return {void}
	 */
	public onCancelRemoveItemButtonClick(_evt, _params, dialog) {
		doLog && console.log(LOG_TAG, '-onCancelRemoveItemButtonClick', _evt);
	}

	/**
	 * @method selectCategory
	 * Setup the category selected on localStorage and filter products based on the selection.
	 * It will allow the browser detect the latest category selected by the user.
	 * @param {Object} _category Optional variable with the category data to store in the localStorage, in case not be present as argument will take the first of the categories list.
	 * @return {void}
	 */
	public selectCategory(_category?) {
		let category = _category || null;
		if (!category && this.productCategories && this.productCategories.length > 0) {
			category = this.productCategories[0];
		}
		if (category) {
			this.categorySelected = category;
			localStorage.setItem('categorySelected', JSON.stringify(category));
			this.filterProducts(category.id);
		} else {
			this.cleanCategorySelection();
		}
	}

	/**
	 * @method cleanCategorySelection
	 * Cleans the categories and products filtered per category from storage and memory.
	 * @return {void}
	 */
	public cleanCategorySelection() {
		localStorage.removeItem('categorySelected');
		this.categorySelected = null;
		this.productsFiltered = [];
	}

	/**
	 * @method onDragEventStart
	 * Initialize the DragEvent.
	 * @param {Number} _src the initial value to compare the position.
	 * @param {Object} _evt the `DragDropEvent` `dragStart` returns the index value where the item starts.
	 * @return {void}
	 */
	public onDragEventStart(_src: number, _evt: DragEndEvent, _type?: string) {
		doLog && console.log(LOG_TAG, '-onDragEventStart', _evt.index);
	}

	/**
	 * @method onDragEventEnds
	 * Initialize the DragEvent and calls the `resortIndexes()` method to re-map index values on terms array.
	 * @param {Number} _src the initial value to compare the position.
	 * @param {Object} _evt the `DragDropEvent` `dragEnd` returns the index value where the item ends.
	 * @param {String} _type the item type to switch and map the index values.
	 * @return {void}
	 */
	public onDragEventEnds(_src: number, _evt: DragEndEvent, _type: string) {
		doLog && console.log(LOG_TAG, '-onDragEventEnds', _evt.index);
		this.reSortIndexes(_type);
	}

	/**
	 * @method onAddNewItemButtonClick
	 * Add new productCategory or Product to the catalogueData.
	 * @param {Object} _evt the `AddNewItemButton` click event.
	 * @param {String} _type The item type to add to the catalogueData.
	 * @return {void}
	 */
	public onAddNewItemButtonClick(_evt, _params, _templateActions) {
		doLog && console.log(LOG_TAG, 'onAddNewItemButtonClick', _params);
		this.action = 'add';
		this.buttonAction = 'Save';

		switch (_params) {
			case 'productCategory':
				const newCategory = {
					id: null,
					versionId: this.versionSelected.id,
					name: null,
					order: null,
					seq: null,
				};

				this.openProductCategoryDialog('New  Category', _templateActions, newCategory, false, 208.5);
				break;
			case 'product':
				const newProduct = {
					id: null,
					categoryId: this.categorySelected.id,
					versionId: this.versionSelected.id,
					categoryName: this.categorySelected.name,
					hasItad: false,
					itadValue: 0,
					ratesEnabled: ['fmv'],
					name: null,
					order: null,
					seq: null,
					terms: null,
				};

				this.openProductDialog('New  Product', _templateActions, newProduct, false, 325.5);
				break;
			default:
				// nothing to do.
				break;
		}
	}

	/**
	 * @method onEditItemButtonClick
	 * Initializes the edit mode of the item selected cloning the found value as temp value
	 * to avoid lose the original data in case we need cancel the edit mode.
	 * @param {Object} _evt the `EditItemButtonClick` click event.
	 * @param {Object} _params the item object with data to compare and find the element to edit.
	 * @param {Object} _params.item the item object to find and list its children.
	 * @param {Number} _params.item.categoryId the category ID to find the productCategory to edit.
	 * @param {Number} _params.item.productID the product ID to find the product to edit.
	 * @return {void}
	 */
	public onEditItemButtonClick(_evt, _params, _templateActions) {
		doLog && console.log(LOG_TAG, 'onEditItemButtonClick', _evt, _params, _templateActions);
		this.buttonAction = 'Save';
		this.action = 'edit';

		switch (_params.type) {
			case 'productCategory':
				const tempProductCategory = _.clone(_params.item);
				this.openProductCategoryDialog('Edit Category', _templateActions, tempProductCategory, false, 208.5);
				break;
			case 'product':
				const tempProduct = _.clone(_params.item);
				this.openProductDialog('Edit Product', _templateActions, tempProduct, false, 325.5);
				break;
			default:
				// nothing to do
				break;
		}
	}

	/**
	 * @method onRemoveItemButtonClick
	 * Request to remove item from array and display message to confirm.
	 * @param {Object} _evt the `RemoveItemButton` click event.
	 * @param {Object} _params the item object to find and remove.
	 * @param {Object} _params.item the item object to find to remove.
	 * @param {Number} _params.item.categoryId the category ID to find the productCategory to remove.
	 * @param {Number} _params.item.productID the product ID to find the product to remove.
	 * @return {void}
	 */
	public onRemoveItemButtonClick(_evt, _params, _templateActions) {
		this.action = 'remove';
		this.isDelete = true;
		this.buttonAction = 'Delete';

		switch (_params.type) {
			case 'product':
				this.openProductDialog('Delete Product', _templateActions, _params.item, true);
				break;
			case 'productCategory':
				this.openProductCategoryDialog('Delete  Category', _templateActions, _params.item, true);
				break;
			default:
				// do nothing
				break;
		}
	}

	/**
	 * @method onViewChildrenItemsClick
	 * Initializes the active mode of the category to filter the products and display own product children.
	 * @param {Object} _evt the `ViewChildrenItemsButton` double click event.
	 * @param {Object} _params the item object with data to compare and find the element to list its children.
	 * @param {Object} _params.item the item object to find and list its children.
	 * @param {Number} _params.item.categoryId the term ID to find the category to list its children.
	 * @return {void}
	 */
	public onViewChildrenItemsClick(_evt, _params) {
		doLog && console.log(LOG_TAG, 'onViewChildrenItemsClick', _evt, _params);
		this.categorySelected = _params.item;
		this.filterProducts(_params.item.id);
		this.selectCategory(_params.item);
	}

	/**
	 * @method handleDialogSubmitButtonClick
	 * Handle the `DialogSubmitButton` click to save the data from the dialog into the catalogueData
	 * and stores it into localstorage to regenerate the grids.
	 * @param {Object} _evt the `DialogSubmitButton` click event.
	 * @return {void}
	 */
	public async handleDialogSubmitButtonClick(_evt) {
		let action;
		doLog && console.log(LOG_TAG, 'handleDialogSubmitButtonClick', this.action);
		this.showLoader();
		switch (this.action) {
			case 'add':
				action = this.addNewItem(this.dialogRefComponent.type, this.dialogRefComponent.item);
				break;
			case 'edit':
				action = this.editItem(this.dialogRefComponent.type, this.dialogRefComponent.item);
				break;
			case 'remove':
				action = this.removeItem(this.dialogRefComponent.type, this.dialogRefComponent.item);
				break;
			default:
				// nothing to do
				break;
		}
		this.dialogRef.close();
		await action;
		this.hideLoader();
		_evt.preventDefault();
	}

	/**
	 * @method handleDialogCloseButtonClick
	 * Handle the `DialogSubmitButton` click to close the dialog.
	 * @param {Object} _evt the `handleDialogCloseButtonClick` click event.
	 * @return {void}
	 */
	public handleDialogCloseButtonClick(_evt) {
		this.dialogRef.close();
	}

	/**
	 * @method onReturnButtonClick
	 * Return to dashboard module.
	 * @return {void}
	 */
	public async onReturnButtonClick(_evt) {
		doLog && console.log(LOG_TAG, '- onReturnButtonClick');
		this.showLoader();
		const orderCategories = _.map(this.productCategories, (_category, _index) => {
			return _.extend({ id: _category.id, order: _category.order });
		});

		const orderProducts = _.map(this.products, (_product, _index) => {
			const category = _.find(orderCategories, { id: _product.categoryId });
			return _.extend({ id: _product.id, order: _product.order, categoryId: _product.categoryId, categoryName: category.name });
		});

		if (this.sortedIndex) {
			this._dataManagerService
				.batchProductsCategoriesUpdate({ categories: orderCategories, products: orderProducts })
				.then((_batchResponse) => {
					this.cleanCategorySelection();
					this._router.navigate([this.validPath]);
				});
		} else {
			this._router.navigate([this.validPath]);
		}
	}

	/**
	 * @method loadVersionSelected
	 * Handles the load of terms at the begining to show terms in version selected.
	 * @return {void}
	 */
	public loadVersionSelected(versionSelected?: any) {
		doLog && console.log(LOG_TAG, '- loadVersionSelected', versionSelected);

		if (!versionSelected) {
			this.productCategories = [];
			this.products = [];
			return;
		}

		this.productCategories = [];
		this.productsFiltered = [];

		this.productCategories = _.sortBy(versionSelected.categories, ['order']);
		this.products = _.sortBy(versionSelected.products, ['categoryId', 'order']);
		this.versionSelected = versionSelected;

		this.validateProductCategories();

		_.defer(() => {
			this.isRendered = true;
			this.hideLoader();
			this._toast.clear();
		});
	}
	/**
	 * @method validateProductCategories
	 * Validate if have values productCategories and sorter data
	 * @return {void}
	 */
	public validateProductCategories(): void {
		if (this.productCategories) {
			// Order the array using descendant way, since the record that has the biggest value in the order
			// property must be displayed at the top
			this.productCategories.sort((a, b) => {
				if (a.order > b.order) {
					return 1;
				}
				if (a.order < b.order) {
					return -1;
				}
				// a must be equal to b
				return 0;
			});

			if (!this.categorySelected && this.productCategories && this.productCategories.length > 0) {
				this.selectCategory(this.productCategories[0]);
			}
		} else {
			this.productCategories = [];
		}
	}
	/**
	 * @method filterProducts
	 * Filter products by category when a category is selected to display children.
	 * @param {Number} _categoryId the category ID to filter.
	 * @return {void}
	 */
	public filterProducts(_categoryId) {
		doLog && console.log(LOG_TAG, '- filterProducts');
		this.productsFiltered = _.filter(this.products, (_product) => {
			return _product.categoryId === _categoryId;
		});

		if (this.productsFiltered) {
			// Order the array using descendant way, since the record that has the biggest value in the order
			// property must be displayed at the top
			this.productsFiltered.sort((a, b) => {
				if (a.order > b.order) {
					return 1;
				}
				if (a.order < b.order) {
					return -1;
				}
				// a must be equal to b
				return 0;
			});
		}
	}

	/**
	 * @method reSortIndexes
	 * Map index values from terms array based on sort order from `DragDropEvent`
	 * @param {String} _type the item type to switch and map the index values.
	 * @return {void}
	 */
	public reSortIndexes(_type) {
		this.sortedIndex = true;
		switch (_type) {
			case 'product':
				// For sort index: the element that is displayed at the top of the kendo control must be
				// the element that has the smallest value in the 'order' property
				// due that the createRateCard method return a rateCard record with the smallest value in its order property
				// and it is putting at the top of the list.
				// For this reason, we assign the order value as descedant
				for (let i = 0; i < this.productsFiltered.length; i += 1) {
					this.productsFiltered[i].order = i + 1;
				}
				break;
			case 'productCategory':
				// For sort index: the element that is displayed at the top of the kendo control must be
				// the element that has the smallest value in the 'order' property
				// due that the createRateCard method return a rateCard record with the smallest value in its order property
				// and it is putting at the top of the list.
				// For this reason, we assign the order value as descedant
				for (let i = 0; i < this.productCategories.length; i += 1) {
					this.productCategories[i].order = i + 1;
				}
				break;
			default:
				// do nothing
				break;
		}
	}

	/**
	 * @method addNewItem
	 * Add new item to the catalogue data.
	 * @param {String} _type Item type to add to the catalogue.
	 * @param {Object} _item Item to add to the catalogue data.
	 * @return {void}
	 */
	public async addNewItem(_type, _item) {
		doLog && console.log(LOG_TAG, 'addNewItem');
		this.showLoader();
		switch (_type) {
			case 'productCategory':
				this.productCategories = [];
				const newCategory = {
					versionId: _item.versionId,
					name: _item.name,
					order: _item.order,
				};
				const categoryResponse = await this._dataManagerService.createCategory(newCategory);
				const { categories = [], products = [] } = this._dataManagerService.versionSelected || {};
				this.productCategories = categories;
				this.products = products;
				const categorySelected = _.find(this.productCategories || [], { name: _item.name });
				this.reSortIndexes('productCategory');
				if (categoryResponse) {
					this.selectCategory(categoryResponse);
				} else {
					this.selectCategory(categorySelected);
				}
				this.sortedIndex = true;
				if (!categorySelected) {
					this.sortedIndex = false;
				}
				break;
			case 'product':
				const newProduct = {
					categoryId: _item.categoryId,
					versionId: _item.versionId,
					name: _item.name,
					hasItad: _item.hasItad,
					itadValue: _item.itadValue,
					ratesEnabled: _item.ratesEnabled,
					order: _item.order,
				};
				const productResponse = await this._dataManagerService.createProduct(newProduct);
				let productSelected;
				if (productResponse) {
					const category = _.find(this.productCategories, { id: productResponse.categoryId });
					this.selectCategory(category);
				} else {
					this.productCategories = this.versionSelected.categories;
					this.products = this.versionSelected.products;
					productSelected = _.find(this.products, {
						name: _item.name,
						hasItad: _item.hasItad,
						ratesEnabled: _item.ratesEnabled,
					});
					if (productSelected) {
						const categoryProductSelected = _.find(this.productCategories, {
							id: productSelected.categoryId,
						});
						this.selectCategory(categoryProductSelected);
					} else {
						this.selectCategory(this.categorySelected);
					}
				}
				this.sortedIndex = true;
				if (!productSelected) {
					this.sortedIndex = false;
				}
				break;
			default:
				// nothing to do
				break;
		}
	}

	/**
	 * @method editItem
	 * Edit item on the catalogue data from tempValue using ngModel.
	 * @param {String} _type Item type to edit from the catalogue.
	 * @param {Object} _item Item to edit from the catalogue data.
	 * @return {void}
	 */
	public async editItem(_type, _item) {
		doLog && console.log(LOG_TAG, 'editItem');
		this.showLoader();
		switch (_type) {
			case 'productCategory':
				const originalProductCategory = _.find(this.productCategories, {
					id: _item.id,
				});
				if (originalProductCategory) {
					const updatedCategory = {
						id: _item.id,
						versionId: _item.versionId,
						name: _item.name,
						order: _item.order,
					};
					const categoryResponse = await this._dataManagerService.updateCategory(updatedCategory);
					if (categoryResponse) {
						originalProductCategory.name = categoryResponse.name;
						this.sortedIndex = true;
						this.selectCategory(originalProductCategory);
					} else {
						this.productCategories = this.versionSelected.categories;
						this.products = this.versionSelected.products;
						const categoryProductSelected = _.find(this.productCategories, {
							name: updatedCategory.name,
						});
						this.selectCategory(categoryProductSelected);
					}
					this.hideLoader();
				}
				break;
			case 'product':
				const originalProduct = _.find(this.products, {
					id: _item.id,
				});
				if (originalProduct) {
					const updatedProduct = {
						id: _item.id,
						categoryId: _item.categoryId,
						versionId: _item.versionId,
						name: _item.name,
						hasItad: _item.hasItad,
						itadValue: _item.itadValue,
						ratesEnabled: _item.ratesEnabled,
						order: _item.order,
						terms: _item.terms,
					};

					const productResponse = await this._dataManagerService.updateProduct(updatedProduct);
					if (productResponse) {
						// Update the value from the response
						originalProduct.name = productResponse.name;
						originalProduct.categoryId = productResponse.categoryId;
						originalProduct.versionId = productResponse.versionId;
						originalProduct.hasItad = productResponse.hasItad;
						originalProduct.itadValue = productResponse.itadValue;
						originalProduct.ratesEnabled = productResponse.ratesEnabled;
						originalProduct.terms = productResponse.terms;
						this.sortedIndex = true;
					} else {
						this.productCategories = this.versionSelected.categories;
						this.products = this.versionSelected.products;
						const productSelected = _.find(this.products, {
							name: _item.name,
							hasItad: _item.hasItad,
							ratesEnabled: _item.ratesEnabled,
						});
						if (productSelected) {
							const categoryProductSelected = _.find(this.productCategories, {
								id: productSelected.categoryId,
							});
							this.selectCategory(categoryProductSelected);
						} else {
							this.selectCategory(this.categorySelected);
						}
					}
					_.defer(() => {
						this.hideLoader();
					});
				}
				break;
			default:
				// nothing to do
				break;
		}
	}

	/**
	 * @method removeItem
	 * Remove item from catalogue.
	 * @param {Boolean} _type Type of item to remove from catalogue.
	 * @param {Object} _item Item to remove from catalogue.
	 * @return {void}
	 */
	public async removeItem(_type, _item) {
		let tempValue;
		this.showLoader();
		switch (_type) {
			case 'product':
				tempValue = _.find(this.productsFiltered, (_product) => {
					return _product.id === _item.id;
				});

				if (tempValue) {
					const response = await this._dataManagerService.removeProduct(tempValue);
					this.productCategories = this.versionSelected.categories;
					this.products = this.versionSelected.products;
					const tempCategorySelected = _.find(this.productCategories, {
						name: this.categorySelected.name,
					});
					if (response) {
						_.remove(this.products, { id: tempValue.id });
					}
					this.selectCategory(tempCategorySelected);
					this.sortedIndex = true;
					if (!response) {
						this.sortedIndex = false;
					}
					_.defer(() => {
						this.hideLoader();
					});
				}
				break;
			case 'productCategory':
				tempValue = _.find(this.productCategories, (_category) => {
					return _category.id === _item.id;
				});

				if (tempValue) {
					const response = await this._dataManagerService.removeCategory(tempValue);
					const tempCategorySelected = _.find(this.productCategories, {
						name: tempValue.name,
					});
					this.productCategories = this.versionSelected.categories;
					this.products = this.versionSelected.products;
					if (tempCategorySelected && response) {
						_.remove(this.productCategories, tempCategorySelected);
						_.remove(this.products, { categoryId: tempCategorySelected.id });
					}
					this.cleanCategorySelection();
					this.selectCategory();
					if (response) {
						this.sortedIndex = true;
					}
					_.defer(() => {
						this.hideLoader();
					});
				}
				break;
			default:
				// do nothing;
				break;
		}
	}

	/**
	 * @method validateResponseError
	 * Makes an action depending of the HttpResponse status code
	 * @param {Object} _responseError HttpResponse of a HttpRequest.
	 * @return {void}
	 */
	public validateResponseError(_responseError) {
		this.dialogRefUnexpectedError = this._dialogService.open({
			title: 'UNEXPECTED ERROR',
			content: _responseError.error.message,
			actions: this.dialogActionsUnexpectedErrorTemplateref,
		});
	}

	/**
	 * @method dialogActionsUnexpectedErrorClose
	 * This method intercept the "OK click button" event to close the Unexpected Error dialog
	 * if it was launched
	 * @param {Object} _evt event parameter for `OK ClickButton` of the Unexpected Error dialog.
	 * @return {void}
	 */
	public dialogActionsUnexpectedErrorClose(_evt) {
		this.dialogRefUnexpectedError.close();
	}

	/**
	 * @method openProductCategoryDialog
	 * Method that helps to open the product Category	 Dialog with the create, update and delete options.
	 * @param {String} _tittle tittle text for the dialog.
	 * @param {TemplateRef} _templateActions dialogActions for the template that should be displayed.
	 * @param {Object} _productCategory product category information that should displayed to be created, updated or deleted.
	 * @param {Booelan} _isDelete flag that indicates if is a delete action
	 * @param {Number} _height sets the height for the pop up
	 * @return {void}
	 */
	public openProductCategoryDialog(_title, _templateActions, _productCategory, _isDelete = false, _height = 195) {
		this.dialogRef = this._dialogService.open({
			title: _title,
			content: ProductCategoriesDialogComponent,
			actions: _templateActions,
			height: _height,
		});

		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.item = _productCategory;
		this.dialogRefComponent.type = 'productCategory';
		this.dialogRefComponent.isDelete = _isDelete;
		this.dialogRefComponent.productCategoriesList = this.productCategories;
		if (_title === 'Edit Category') {
			this.dialogRefComponent.edit = true;
		}
	}

	/**
	 * @method openProductDialog
	 * Method that helps to open the Product Dialog with the create, update and delete options.
	 * @param {String} _tittle tittle text for the dialog.
	 * @param {TemplateRef} _templateActions dialogActions for the template that should be displayed.
	 * @param {Object} _product product information that should displayed to be created, updated or deleted.
	 * @param {Booelan} _isDelete flag that indicates if is a delete action
	 * @param {Number} _height sets the height for the pop up
	 * @return {void}
	 */
	public openProductDialog(_tittle, _templateActions, _product, _isDelete = false, _height = 195) {
		this.dialogRef = this._dialogService.open({
			title: _tittle,
			content: ProductDialogComponent,
			actions: _templateActions,
			height: _height,
		});

		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.productCategories = this.productCategories;
		this.dialogRefComponent.item = _product;
		this.dialogRefComponent.type = 'product';
		this.dialogRefComponent.isDelete = _isDelete;
		this.dialogRefComponent.productsList = this.products;
	}

	/**
	 * @method displayRatesEnabled
	 * Setup the label to display the kind of rates enabled on the product.
	 * @param {Object} _item Stores the related data to the product selected.
	 * @return {String}
	 */
	public displayRatesEnabled(_item) {
		let rateType: string;
		switch (_item.ratesEnabled.length) {
			case 2:
				rateType = 'FMV - $1';
				break;
			case 1:
				rateType = _item.ratesEnabled[0] === 'fmv' ? 'FMV' : '$1';
				break;
			default:
				rateType = null;
				break;
		}
		return rateType;
	}

	/**
	 * @method hideLoader
	 * Hides the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public hideLoader() {
		this._busyService$.hideLoading();
	}

	/**
	 * @method showLoader
	 * Displays the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public showLoader() {
		this._busyService$.showLoading();
	}
}
