import { AfterContentInit, Component, isDevMode, OnDestroy, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { AppSettings, AuthService, BusyService, DEFAULT_PERMISSION, doLog, LayoutService, WebServices } from '@core/index';
import { DataManagerService } from '@core/services/data-manager.service';
import { ErrorService } from '@core/services/error.service';
import { RateCardsWebService } from '@core/services/ratecards.webservice';
import { DialogCloseResult, DialogRef, DialogService } from '@progress/kendo-angular-dialog';
import { DataEvent, DragEndEvent, SortableComponent } from '@progress/kendo-angular-sortable';
import { TermsDialogComponent } from '@shared/components/shared/terms-dialog/terms-dialog.component';
import { IProductCategories } from '@shared/models/product-categories.model';
import { IProduct } from '@shared/models/product.model';
import { RateCardTerms } from '@shared/models/ratecard-terms.model';
import { ITerm } from '@shared/models/terms.model';
import * as _ from 'lodash';
import * as moment from 'moment';
import { Subscription } from 'rxjs';

const LOG_TAG = '[components/ManageTermsComponent]';

@Component({
	selector: 'app-manage-terms',
	templateUrl: './manage-terms.component.html',
	styleUrls: ['./manage-terms.component.scss'],
})
export class ManageTermsComponent implements OnInit, OnDestroy, AfterContentInit {
	/**
	 * @property {Boolean} isRendered toggle display loading component when document is rendered.
	 */
	public isRendered: boolean = false;

	/**
	 * @property {Object[]} products Stores product list from webservices.
	 */
	public products: IProduct[];

	/**
	 * @property {Object[]} productCategories Stores product categories list from webservices.
	 */
	public productCategories: IProductCategories[];

	/**
	 * @property {Boolean} buttonAction saves the button message on submit
	 */
	public buttonAction;

	/**
	 * @property {Object[]} terms stores the terms from catalogue data.
	 */
	public terms = [];

	/**
	 * @property {string} action stores the action to execute on submit dialog.
	 */
	public dialogAction;

	private rateCardId: string;

	/**
	 * @property {Object} versionSelected Stores the current version data.
	 */
	public versionSelected;

	/**
	 * @property {Object} dialogRef stores the reference to the dialog generated by the `DialogService`
	 * @private
	 */
	public dialogRef: DialogRef;

	/**
	 * @property {Object} dialogRefComponent stores the instance reference from the dialog component generated by the `DialogService`
	 * @private
	 */
	public dialogRefComponent;

	/**
	 * @property {Object} versionSelectedSubscription
	 * @private
	 */
	private versionSelectedSubscription: Subscription;
	/**
	 * @property {Boolean} edited flag is is edit
	 */
	private edited: boolean;
	/**
	 * @property {Boolean} isDisabled flag is is disabled
	 */
	public isDisabled: boolean;
	/**
	 * @property {any} item Item term
	 */
	public item: any;
	/**
	 * @property {string} validPath Receive Url with user permission
	 */
	public validPath: string;

	/**
	 * @property {boolean} isTermRangeValid global variable to check if term range is between 1 and 99.
	 * @private
	 */

	private isTermRangeValid = false;

	constructor(
		private _dialogService: DialogService,
		private _appSettings: AppSettings,
		private _router: Router,
		private _layoutService: LayoutService,
		private _rateCardsWebService: RateCardsWebService,
		private _webService: WebServices,
		private _dataManagerService: DataManagerService,
		private _busyService$: BusyService,
		private _errorService: ErrorService,
		private _authService: AuthService
	) {
		const userPermission = this._authService.getUserPermissions() || DEFAULT_PERMISSION;
		this.validPath = `/${userPermission}/dashboard`;
	}

	public ngOnInit() {
		this.isDisabled = true;
		this.showLoader();
		this._layoutService.setNavControlsVisibility(false);
		if (this._router.url !== this.validPath) {
			this._layoutService.hideRateCardSelectors();
		}
	}

	public ngOnDestroy() {
		this.versionSelectedSubscription.unsubscribe();
	}

	/**
	 * @method ngAfterContentInit
	 * Respond after Angular projects external content into the component's view / the view that a directive is in.
	 * @return {void}
	 */
	public ngAfterContentInit() {
		this.versionSelectedSubscription = this._dataManagerService.versionSelected$.subscribe((versionSelected) => {
			this.loadVersionSelected(versionSelected);
		});
	}

	/**
	 * @method handleDialogCloseButtonClick
	 * Handle cancellation
	 * @return {void}
	 */
	public handleDialogCloseButtonClick(_evt) {
		this.dialogRef.close();
	}

	/**
	 * @method onAddTermButtonClick
	 * On Add Term button click event, handles the event to add term
	 * @param _params {Object} stores the item data to add.
	 * @return {void}
	 */
	public onAddTermButtonClick(_evt, _params, _templateActions) {
		const lastTerm = _.last(this.terms);
		const newTerm = {
			termID: lastTerm ? lastTerm.termID + 1 : 1001,
			name: null, // must be a string due kendo-ui requirements.
			value: null,
			date: moment().toDate(),
			index: null,
			status: 1,
		};
		this.dialogRef = this._dialogService.open({
			title: 'New Term',
			content: TermsDialogComponent,
			actions: _templateActions,
			width: 295.5,
			height: 171.5,
		});
		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.item = newTerm;
		this.dialogRefComponent.terms = this.terms;
		this.buttonAction = 'Save';
		this.dialogAction = 'add';
	}

	/**
	 * @method onRemoveTermButtonClick
	 * On Remove term click event, handles the event to remove term
	 * @param _evt The click event of remove term button.
	 * @param _params {Object} stores the item data to remove.
	 * @param _templateActions pass through the components the submit and cancel button actions template.
	 * @return {void}
	 */
	public onRemoveTermButtonClick(_evt, _params, _templateActions) {
		const status = 1;
		const currentTerms = _.filter(this.terms, { status: 1 });
		if (currentTerms.length === status) {
			this.displayDeleteTermDialogNoRemove(_templateActions, _params);
			return;
		}
		this.displayDeleteTermDialog(_templateActions, _params);
	}

	/**
	 * @method onSubmitTerms
	 * Submit terms to webservice in order to store them into the current version.
	 * @param _evt The done button click event.
	 * @return {void}
	 */
	public async onSubmitTerms(_evt) {
		this.showLoader();
		if (this.edited) {
			const stringTermsArray = [];
			const terms = _.chain(this.terms)
				.filter((term) => term.status === 1)
				.map('name')
				.value();

			return this._dataManagerService
				.updateTerms(terms)
				.then(() => {
					this._router.navigate([this.validPath]);
				})
				.catch((_error) => {
					this.hideLoader();
					this._errorService.validateResponseError(_error);
				});
		}
		return this._router.navigate([this.validPath]);
	}

	/**
	 * @method handleDialogSubmitButtonClick
	 * Handle submission from dialogs.
	 * @return {void}
	 */
	public handleDialogSubmitButtonClick(_evt) {
		this.dialogRefComponent.errorMessage = '';
		this.dialogRefComponent.showErrorMessage = false;
		if (
			_.filter(this.terms, { status: 1 }).length >= this._appSettings.getColumnsSettings().maxTermsColumns &&
			this.dialogAction === 'add'
		) {
			this.dialogRefComponent.errorMessage = 'There is a maximum of 5 terms allowed on this version.';
			this.dialogRefComponent.showErrorMessage = true;
			return;
		}

		this.validateSubmitAction(this.dialogAction);
		if (!this.isTermRangeValid && this.dialogRefComponent.showErrorMessage === true) {
			this.isTermRangeValid = true;
			return;
		}
		this.edited = true;
		this.dialogRef.close();
		return;
	}

	/**
	 * @method loadVersionSelected
	 * @public
	 * Handles the load of terms at the begining to show terms in version selected.
	 * @return {void}
	 */
	public loadVersionSelected(versionSelected?: any) {
		doLog && console.log(LOG_TAG, '- loadVersionSelected', versionSelected);

		if (!versionSelected) {
			this.terms = [];
			this.versionSelected = null;
			return;
		}

		this.updateTermsVersion(versionSelected.terms);
		this.versionSelected = versionSelected;

		if (this.versionSelected) {
			_.defer(() => {
				this.hideLoader();
			});
		}
		this.countTerms();
	}
	/**
	 * @method hideLoader
	 * Hides the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public hideLoader() {
		this._busyService$.hideLoading();
	}
	/**
	 * @method showLoader
	 * Displays the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public showLoader() {
		this._busyService$.showLoading();
	}
	/**
	 * @method countTerms
	 * Enable or disable add term button when terms are at top.
	 * @return {void}
	 */
	public countTerms() {
		const terms = _.filter(this.terms, (_term) => _term.status !== -1);
		this.isDisabled = !!(terms.length >= 5);
	}
	/**
	 * @method isValidEntry
	 * Validates if term value is acceptable based on business rules.
	 * @param {Object} _value The term object to validate.
	 * @return {Boolean}
	 */
	public isValidEntry(_value) {
		doLog && console.log(LOG_TAG, 'isValidEntry', _value);
		return _value.name !== null && _value.name > 0 && _value.name <= 99;
	}
	/**
	 * @method displayDeleteTermDialogNoRemove
	 * Display delete term that can`t remove
	 * @param {object} _templateActions Receives template object actions.
	 * @param {object} _params Receives params object.
	 * @return {void}
	 */
	public displayDeleteTermDialogNoRemove(_templateActions, _params): void {
		this.dialogRef = this._dialogService.open({
			title: 'Delete Term',
			content: TermsDialogComponent,
			actions: _templateActions,
		});
		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.item = _params.item;
		this.dialogRefComponent.isDelete = true;
		this.buttonAction = 'OK';
		this.dialogAction = null;
	}
	/**
	 * @method displayDeleteTermDialog
	 * Display delete term dialog
	 * @param {object} _templateActions Receives template object actions.
	 * @param {object} _params Receives params object.
	 * @return {void}
	 */
	public displayDeleteTermDialog(_templateActions, _params): void {
		const month = +_params.item.name > 1 ? 's' : '';
		this.dialogRef = this._dialogService.open({
			title: 'Delete Term',
			content: TermsDialogComponent,
			actions: _templateActions,
			height: 195,
		});
		this.dialogRefComponent = this.dialogRef.content.instance;
		this.dialogRefComponent.item = _params.item;
		this.dialogRefComponent.isDelete = true;
		this.dialogRefComponent.removeMessage = `${_params.item.name} Month${month}`;
		this.dialogRefComponent.origin = 'manageTerms';
		this.buttonAction = 'Delete';
		this.dialogAction = 'delete';
	}
	/**
	 * @method validateSubmitAction
	 * Validate dialog actions to apply depend input type
	 * @param {string} type Receives type action.
	 * @return {void}
	 */
	public validateSubmitAction(type: string): void {
		switch (type) {
			case 'add':
				if (!this.isValidEntry(this.dialogRefComponent.item)) {
					this.dialogRefComponent.errorMessage = 'Introduce a valid entry between 1 and 99.';
					this.dialogRefComponent.showErrorMessage = true;
					this.isTermRangeValid = false;
					return;
				}
				const { item: { name = '' } = {} } = this.dialogRefComponent || {};
				const itemName = '' + name.toString();
				if (
					_.find(this.terms, { termID: this.dialogRefComponent.item.termID, status: 1 }) ||
					_.find(this.terms, { name: itemName, status: 1 })
				) {
					this.dialogRefComponent.errorMessage = 'This Term already exists.';
					this.dialogRefComponent.showErrorMessage = true;
					return;
				}
				this.dialogRefComponent.item.name = itemName;
				this.terms.push(this.dialogRefComponent.item);
				this.countTerms();
				break;
			case 'delete':
				const tempValue = _.find(this.terms, (_term) => {
					return _term.termID === this.dialogRefComponent.item.termID;
				});
				_.extend(tempValue, { status: -1, date: moment().toDate() });
				this.countTerms();
				break;
			default:
				// nothing to do
				this.dialogRef.close();
				break;
		}
	}
	/**
	 * @method updateTermsVersion
	 * Update terms version
	 * @param {Object} terms
	 * @return {void}
	 */
	public updateTermsVersion(terms): void {
		this.terms = _.chain(terms)
			.map((term, index) => {
				return {
					value: Number(term),
				};
			})
			.orderBy(['value'], ['asc'])
			.map((_term, _index) => {
				return {
					termID: 1001 + _index,
					name: _term.value.toString(), // must be a string due kendo-ui requirements.
					value: Number(_term.value),
					date: moment().toDate(),
					_index,
					status: 1,
				};
			})
			.value();
	}
}
