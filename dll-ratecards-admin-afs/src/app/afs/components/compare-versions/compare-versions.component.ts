import { AfterContentChecked, Component, ElementRef, OnDestroy, OnInit, QueryList, TemplateRef, ViewChildren } from '@angular/core';
import { Router } from '@angular/router';
import { AppSettings, AuthService, BusyService, DEFAULT_PERMISSION, LayoutService, ToastService } from '@core/index';
import { DataManagerService } from '@core/services/data-manager.service';
import { DialogRef, DialogService } from '@progress/kendo-angular-dialog';
import { RatefactorsCompareDialogComponent } from '@shared/components/shared/ratefactors-compare-dialog/ratefactors-compare-dialog.component';
import { IRateProgram } from '@shared/interfaces/rate-program.interface';
import { ICompareRates } from '@shared/models/compare-rates.model';
import * as _ from 'lodash';
import { Subscription } from 'rxjs';

const COMPARE_RATE_CARDS = 'Compare Rate Card';
const NOT_VERSION = 'Compare Rate Card';
const SELECT_VERSION = 'You must select a version to compare';
const COMPARE_VERSION_PATH = '/afs/compare-versions';
const SCROLL_WIDTH = ['610px', '610px'];

@Component({
	selector: 'app-compare-versions',
	templateUrl: './compare-versions.component.html',
	styleUrls: ['./compare-versions.component.scss'],
})
export class CompareVersionsComponent implements OnInit, OnDestroy, AfterContentChecked {
	/**
	 * @property {Array} scrollWidth Stores scroll width [610px, 610px]
	 */
	public scrollWidth = [];

	/**
	 * @property {String} versionDate Stores version date of compare
	 */
	public versionDate;

	/**
	 * @property {Object[]} terms Stores the terms
	 */
	public termList: string[];

	/**
	 * @property {Boolean} isLocked detects if the column is locked on the grid.
	 */
	public isLocked: boolean;

	/**
	 * @property {Object[]} items Stores the items out
	 */
	public out: ICompareRates[];

	/**
	 * @property {Object[]} rmv Stores the items rmv
	 */
	public rmv: ICompareRates[];

	/**
	 * @property {String} versionSelectedId version Id from version selected
	 */
	public versionSelectedId: string = null;

	/**
	 * @property {Object} rateCardSelected reference to the current rateCard selected from the data manager
	 */
	public rateCardSelected: IRateProgram;

	/**
	 * @property {string} versionCurrentId version current if to compare vs version selected
	 */
	public versionCurrentId: string = null;

	/**
	 * @property {string} versionSelectedName version name from version selected
	 */
	public versionSelectedName: string = null;

	/**
	 * @property {string} versionCurrentName version current name if to compare vs version selected
	 */
	public versionCurrentName: string = null;

	/**
	 * @property {Object} dialogRef stores the reference to the dialog generated by the `DialogService`
	 */
	public dialogRef: DialogRef;

	/**
	 * @property {Object} dialogRefComponent stores the instance reference from the dialog component generated by the `DialogService`
	 */
	public dialogRefComponent;

	/**
	 * @property {Object} templateNoVersionSelected Contains the template for no version selected.
	 */
	public templateNoVersionSelected;

	/**
	 * @property {Object} dialogRefNoVersionSelected stores the reference to the dialog generated by the `DialogService`
	 */
	public dialogRefNoVersionSelected: DialogRef;

	/**
	 * @property {Object[]} versionSelected Stores the versionSelected
	 */
	public versionSelected;

	/**
	 * @property {Object[]} actualTerm Stores the actual term
	 */
	public actualTerm;

	/**
	 * @property {String} buttonAction button action text to display on dialogs
	 */
	public buttonAction;

	/**
	 * @property {String} dialogAction dialog action to execute depending of the dialog opened.
	 */
	public dialogAction;

	/**
	 * @property {Object[]} colorClass list of classes for adding collor to terms.
	 */
	private colorClass = {
		new: 'new',
		higher: 'higher-rate',
		deleted: 'deleted',
		lower: 'lower-rate',
	};

	/**
	 * @property {string} validPath Receive Url with user permission
	 */
	public validPath: string;

	private subscriptions: Subscription[] = [];

	@ViewChildren('scroll')
	private scroll: QueryList<ElementRef>;
	@ViewChildren('grid')
	public grid: QueryList<ElementRef>;

	constructor(
		private _layoutService: LayoutService,
		private _dataManagerService: DataManagerService,
		private _toast: ToastService,
		private _busyService$: BusyService,
		private _router: Router,
		private _dialogService: DialogService,
		private _appSettings: AppSettings,
		private _authService: AuthService
	) {
		this.scrollWidth = SCROLL_WIDTH;
	}

	public ngOnInit() {
		this._layoutService.setNavControlsVisibility(false);

		const subscriptionVersionSelected = this._dataManagerService.versionSelected$.subscribe((versionSelected) => {
			this.loadVersionSelected(versionSelected);
		});
		this.subscriptions.push(subscriptionVersionSelected);

		const subscriptionRateCardSelected = this._dataManagerService.rateCardSelected$.subscribe((versionSelected) => {
			this.loadRateCardSelected(versionSelected);
		});
		this.subscriptions.push(subscriptionRateCardSelected);

		const subscriptionTrackExportVersionState = this._layoutService.trackExportVersionState.subscribe((_version) => {
			this.versionDate = _version;
		});
		this.subscriptions.push(subscriptionTrackExportVersionState);

		this._toast.clear();

		this.hideLoader();
	}

	public ngOnDestroy() {
		_.each(this.subscriptions, (subscription) => {
			subscription.unsubscribe();
		});
	}

	/**
	 * @method ngAfterContentChecked
	 * Respond after Angular checks the content projected into the directive/component.
	 * @return {void}
	 */
	public ngAfterContentChecked() {
		if (!this.grid) {
			return;
		}
		const grids = this.grid.toArray();
		const scrolls = this.scroll.toArray();
		// Validate if scrolls exists on grid based on terms columns length and then apply the scroll functionality.
		if (scrolls && scrolls.length > 0) {
			_.each(grids, (_grid, _index) => {
				const tempGrid: ElementRef | any = _grid;
				const scrollableGrid: ElementRef | any = tempGrid.wrapper.nativeElement.children[0].children[1].children[1];
				const scrollerElement: ElementRef | any = scrolls[_index].nativeElement;
				this.scrollWidth[_index] = scrollableGrid.children[0].children[0].clientWidth + 'px';
				scrollerElement.onscroll = (_event) => {
					const scrollPosition = _event.srcElement.scrollLeft;
					scrollableGrid.scrollTo(scrollPosition, 0);
				};
				scrollableGrid.onscroll = (_event) => {
					const scrollPosition = _event.srcElement.scrollLeft;
					scrollerElement.scrollTo(scrollPosition, 0);
				};
			});
		}
	}

	/**
	 * @method onCompareRatesButtonClick
	 * Compare rate cards.
	 * @param {Object} _evt the button click event.
	 * @param {Object} _templateActions the template actions to pass through the dialog and manage the submission.
	 * @param {Object} _templateNoVersion the template actions to pass through the dialog if there's no more than one version.
	 * @param {Object} _templateNoVersionSelected the template actions to pass through the dialog if there's no version selected
	 * @return {void}
	 */
	public onCompareRatesButtonClick(_evt, _templateActions, _templateNoVersion) {
		this.versionSelectedId = 'NoSelected';
		if (this.rateCardSelected && this.rateCardSelected.versions) {
			const versionsLength =
				this.rateCardSelected.versions && this.rateCardSelected.versions.length > 1 ? this.rateCardSelected.versions.length : 0;
			this.dialogRef = this._dialogService.open({
				width: versionsLength === 0 ? 390 : 299,
				height: versionsLength === 0 ? 150 : 380,
				title: versionsLength === 0 ? NOT_VERSION : COMPARE_RATE_CARDS,
				content: RatefactorsCompareDialogComponent,
				actions: versionsLength === 0 ? _templateNoVersion : _templateActions,
			});
			this.dialogRefComponent = this.dialogRef.content.instance;
			this.dialogRefComponent.currentRateCard = this.rateCardSelected;
			this.dialogRefComponent.versionSelected = this.versionSelected;
			this.dialogRefComponent.environment = {
				name: this._appSettings.appCustomOptions.env,
			};
			this.buttonAction = 'Compare';
			this.dialogAction = 'compare';
			return;
		}
		return null;
	}

	/**
	 * @method handleDialogSubmitButtonClick
	 * Handles the dialog submit button click event and triggers the compare functionality.
	 * @return {void}
	 */
	public async handleDialogSubmitButtonClick(_evt) {
		this.showLoader();
		this.dialogRef.close();
		this.setLoaderMessage('Comparing Rates...');
		if (this.dialogAction === 'compare') {
			if (!this.dialogRefComponent.versionSelectedId || this.dialogRefComponent.versionSelectedId === 'NoSelected') {
				this.dialogRefNoVersionSelected = this._dialogService.open({
					title: COMPARE_RATE_CARDS,
					content: SELECT_VERSION,
					actions: this.templateNoVersionSelected,
				});
				this.hideLoader();
				return;
			} else {
				this.versionCurrentId = this.dialogRefComponent.versionCurrentId;
				this.versionSelectedId = this.dialogRefComponent.versionSelectedId;
				this.versionCurrentName = this.dialogRefComponent.versionCurrentName;
				this.versionSelectedName = this.dialogRefComponent.versionSelectedName;
				const compareResponse = await this._dataManagerService.compareVersions({
					versionId: this.versionSelectedId,
					versionToCompare: this.versionCurrentId,
					versionCurrentName: this.versionCurrentName,
					versionSelectedName: this.versionSelectedName,
				});
				this.hideLoader();
			}
		}
	}

	/**
	 * @method loadRateCardSelected
	 * Updates the template's rateCardSelected
	 * @param {object} rateCardSelected new rateCardSelected to load
	 * @return {void}
	 */
	public loadRateCardSelected(rateCardSelected: any) {
		this.rateCardSelected = rateCardSelected;
	}

	/**
	 * @method loadVersionSelected
	 * validate any changes on the component.
	 * @param {Object} versionSelected the version selected.
	 * @return {void}
	 */
	public loadVersionSelected(versionSelected?) {
		this.versionSelected = null;
		const MAX_TERMS_COLUMNS = this._appSettings.appSettings.maxTermsColumns;

		if (!versionSelected) {
			this.versionSelected = null;
			this.termList = [];
			this.out = [];
			this.rmv = [];
			return;
		}
		if (versionSelected.comparedData) {
			this.termList = versionSelected.comparedData.terms;
			if (this.termList.length >= MAX_TERMS_COLUMNS) {
				this.isLocked = true;
			}
			const terms = _.orderBy(
				_.map(this.termList, (_term) => {
					return { value: Number(_term) };
				}),
				['value'],
				['asc']
			);

			this.termList = _.map(terms, (_term) => _term.value.toString());
			this.out = versionSelected.comparedData.items.out;
			this.rmv = versionSelected.comparedData.items.rmv;
			this.versionCurrentName = versionSelected.comparedData.versionCurrentName;
			this.versionSelectedName = versionSelected.comparedData.versionSelectedName;
		} else {
			if (this._router.url === COMPARE_VERSION_PATH) {
				this._router.navigate(['/dashboard']);
			}
		}
		this.versionSelected = versionSelected;
	}

	public async onReturnButtonClick() {
		const userPermission = this._authService.getUserPermissions() || DEFAULT_PERMISSION;
		this.validPath = `/${userPermission}/dashboard`;
		this._router.navigate([this.validPath]);
	}

	/**
	 * @method mapClass
	 * validate status
	 * @param {Object} _element the current element terms.
	 * @param {Object} _current the current term.
	 * @return {string}
	 */
	public mapClass(_element, _current) {
		let position = null;
		let result;
		const hyphensResult = '--------';
		this.actualTerm = '';
		if (_element.length > 0) {
			position = _element.find((terms) => {
				return terms.term === _current;
			});
		}
		result = !position.status ? '' : this.colorClass[position.status];
		if (position.data.description === null && position.data.previous === null && position.status === null) {
			this.actualTerm = hyphensResult;
		} else {
			this.actualTerm = !position
				? hyphensResult
				: position.data.description
				? position.data.description.toFixed(6)
				: position.data.previous.toFixed(6);
		}
		return result;
	}

	/**
	 * @method handleDialogCloseButtonClick
	 * Handle the `DialogCloseButton` click to close the dialog
	 * @param {Object} _evt the `DialogCloseButton` click event.
	 * @return {void}
	 */
	public handleDialogCloseButtonClick() {
		this.dialogRef.close();
	}

	/**
	 * @method hideLoader
	 * Hides the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public hideLoader() {
		this._busyService$.hideLoading();
	}

	/**
	 * @method showLoader
	 * Displays the `LoadingComponent` subscribing as true the observable value.
	 * @return {void}
	 */
	public showLoader() {
		this._busyService$.showLoading();
	}

	/**
	 * @method setLoaderMessage
	 * Set messate to loader
	 * @param {string} _message Receives messate to diplay in loader
	 * @return {void}
	 */
	public setLoaderMessage(_message: string): void {
		this._busyService$.setLoaderMessage(_message);
	}
}
