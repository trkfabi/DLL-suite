import * as _ from 'lodash';

import { Injectable } from '@angular/core';

import { BehaviorSubject } from 'rxjs';
import { BusyService } from './busy.service';

import { NumberHelper } from '@lib/index';
import { doLog } from '../app-settings';
import { RateCardsService } from './rate-cards.service';
import { RateCardsWebService } from './ratecards.webservice';
import { ToastService } from './toaster.service';
import { WebServices } from './webservices.service';

import { DialogCloseResult, DialogRef, DialogService } from '@progress/kendo-angular-dialog';
import { DeleteVersionDialogComponent } from '@shared/components/shared/delete-version-dialog/delete-version-dialog.component';
import { ErrorDialogComponent } from '@shared/components/shared/error-dialog/error-dialog.component';
import { IRateProgram, IReorderRatePrograms } from '@shared/interfaces';

const LOG_TAG = '[core/services/data-manager.service]';
const VERSION_ID_STRING = 'versionId';
const RATECARD_ID_STRING = 'rateCardId';
const DUPLICATE_TEXT = 'duplicate';
const ERROR_MESSAGE = 'Error message';

/**
 * @class Services.dataManager
 * Service for all the data shared between components and communicating back and forth with the backend
 */
@Injectable()
export class DataManagerService {
	private _rateCardsSubject = new BehaviorSubject<any>(null);
	private _rateCardSelectedSubject = new BehaviorSubject<any>(null);
	private _versionSelectedSubject = new BehaviorSubject<any>(null);

	private _rateCards?: any[];
	private _rateCardSelected?: any = null;
	private _versionSelected?: any = null;

	/**
	 * @property {Observable} rateCards$ observable for any changes on the list of rate cards
	 */
	// tslint:disable-next-line:member-ordering
	public rateCards$ = this._rateCardsSubject.asObservable();

	/**
	 * @property {Observable} rateCardSelected$ observable for any changes on the current rate card selected by the user
	 */
	// tslint:disable-next-line:member-ordering
	public rateCardSelected$ = this._rateCardSelectedSubject.asObservable();

	/**
	 * @property {Observable} versionSelected$ observable for any changes on the current version selected by the user
	 */
	// tslint:disable-next-line:member-ordering
	public versionSelected$ = this._versionSelectedSubject.asObservable();

	/**
	 * @property {number} attemptsToLoadData
	 * Prevents app to loop trying to load data when no version is available on ratecard.
	 */
	private attemptsToLoadData;

	/**
	 * @property {Object[]} versionList desc
	 */
	private versionList;

	/**
	 * @property {Object} dialogRef stores the reference to the dialog generated by the `DialogService`
	 * @private
	 */
	private dialogRef: DialogRef;

	/**
	 * @property {Object} dialogRefComponent stores the instance reference from the dialog component generated by the `DialogService`
	 * @private
	 */
	private dialogRefComponent;

	constructor(
		private _webservices: RateCardsWebService,
		private _rateCardsService: RateCardsService,
		private _dialogService: DialogService,
		private _busyService: BusyService,
		private _toastService: ToastService,
		private _numberHelper: NumberHelper
	) {}

	set rateCards(_rateCards) {
		this._rateCards = _rateCards;
		this._rateCardsSubject.next(_rateCards);
	}

	get rateCards() {
		return this._rateCards;
	}

	set rateCardSelected(_rateCardSelected) {
		this._rateCardSelected = _rateCardSelected;
		this._rateCardSelectedSubject.next(_rateCardSelected);
	}

	get rateCardSelected() {
		return this._rateCardSelected;
	}

	set versionSelected(_versionSelected) {
		this._versionSelected = _versionSelected;
		this._versionSelectedSubject.next(_versionSelected);
	}

	get versionSelected() {
		return this._versionSelected;
	}

	/**
	 * @property {number} intervalTime Stores the interval time.
	 */
	private intervalTime: number = 15000;
	/**
	 * @method fetchRateCardsWithVersion
	 * Obtains the whole list of rate cards, for the given rateCardId, it loads its list of versions, for the versionId, it loads its data: inputs, products, categories, terms, etc
	 * Sends event for rateCards, rateCardSelected, versionSelected
	 * @param {string} _rateCardId ratecard to load, defaults to the first one in the list
	 * @param {string} _versionId version to load, defaults to the version in progress of the _rateCardId
	 * @return {void}
	 */
	public async fetchRateCardsWithVersion(_rateCardId: string = null, _versionId: string = null) {
		doLog && console.debug(`${LOG_TAG} - fetchRateCardsWithVersion - ${_rateCardId} - ${_versionId}`);

		this._busyService.showLoading();

		const { id: rateCardId = null } = this.rateCardSelected || {};
		const { id: versionId = null } = this.versionSelected || {};

		this.rateCardSelected = null;
		this.versionSelected = null;
		this.rateCards = null;

		if (!_rateCardId && !_versionId && localStorage.getItem(RATECARD_ID_STRING) && localStorage.getItem(VERSION_ID_STRING)) {
			_rateCardId = localStorage.getItem(RATECARD_ID_STRING);
			_versionId = localStorage.getItem(VERSION_ID_STRING);
		}

		let rateCardsResponse = await this._webservices.getRateCardInfo(_rateCardId, _versionId);

		if ((!rateCardsResponse && !rateCardsResponse.result) || (rateCardsResponse && rateCardsResponse.result.length === 0)) {
			rateCardsResponse = false;
			return false;
		}

		const { result: rateCards } = rateCardsResponse;

		let rateCardSelected = null;
		let versionSelected = null;

		rateCardSelected = this.findRateCardSelected(rateCards, _rateCardId);

		if (!rateCardSelected) {
			return false;
		}

		const versionListResponse = await this._webservices.getRateCardsVersion(rateCardSelected.id);

		let { versions: versions } = versionListResponse.result || {};

		versions = _.filter(versions, (_version) => {
			return _version.deleted === false;
		});

		// Force  Published version to first position.
		if (rateCardSelected.versionPublished) {
			const isPublished = _.find(versions, { id: rateCardSelected.versionPublished });
			if (isPublished) {
				versions = _.filter(versions, (_version) => {
					return _version.id !== isPublished.id;
				});
				versions.unshift(isPublished);
			}
		}
		// Force  In-Progress version to first position and push the published to second.
		if (rateCardSelected.versionInProgress) {
			const inProgress = _.find(versions, { id: rateCardSelected.versionInProgress });
			if (inProgress) {
				versions = _.filter(versions, (_version) => {
					return _version.id !== inProgress.id;
				});
				versions.unshift(inProgress);
			}
		}

		versionSelected = this.findVersionSelected(_versionId, versions, rateCardSelected);

		if (versionSelected && !versionSelected.inputs && (!this.attemptsToLoadData || this.attemptsToLoadData === 0)) {
			this.fetchRateCardsWithVersion(rateCardSelected.id, versionSelected.id);
			this.attemptsToLoadData = 1;
			return;
		}

		if (rateCardSelected) {
			_.extend(rateCardSelected, { versions });
		}

		if (versionSelected) {
			versionSelected.products = _.map(versionSelected.products, (_product) => {
				const category = _.find(versionSelected.categories, (_category) => {
					return _product.categoryId === _category.id;
				});
				if (category) {
					_.extend(_product, { categoryName: category.name });
				}
				return _product;
			});

			const { inputs = [] } = versionSelected;
			const { products = [] } = versionSelected;

			_.each(inputs, (input) => {
				input.isInput = true;
			});

			_.each(products, (product) => {
				product.isResidual = true;
			});

			versionSelected.terms.sort((a, b) => {
				return Number(a) > Number(b);
			});

			versionSelected.inputsGrouped = _.groupBy(inputs, 'type');

			localStorage.setItem(RATECARD_ID_STRING, rateCardSelected.id);
			localStorage.setItem(VERSION_ID_STRING, versionSelected.id);
		} else {
			versionSelected = null;
			localStorage.removeItem(VERSION_ID_STRING);
			localStorage.removeItem(RATECARD_ID_STRING);
		}

		if (this.rateCardSelected && this.rateCardSelected.versions.length === 0) {
			this.rateCardSelected.versionInProgress = null;
		}

		this.rateCardSelected = rateCardSelected;
		this.versionSelected = versionSelected;
		this.rateCards = _.sortBy(rateCards, 'name') || [];
	}

	/**
	 * @method createVersion
	 * Creates a new version in the given rate card and selects it
	 * Sends event for rateCards, rateCardSelected, versionSelected
	 * @param {string} _rateCardId ratecard to add a new version into
	 * @return {void}
	 */
	public async createVersion(_rateCardId: string, _avoidFetch: boolean = false) {
		let responseNewVersion;
		if (!this.rateCardSelected.versionInProgress) {
			responseNewVersion = await this._webservices.createNewVersion({
				rateCardId: _rateCardId,
			});
		} else {
			const tempVersionSelected = this.versionSelected;
			this._busyService.hideLoading();
			this.dialogRef = this._dialogService.open({
				title: 'Delete In-Progress Version',
				content: DeleteVersionDialogComponent,
				actions: [
					{
						text: 'Cancel',
						action: (_evt) => {
							this.dialogRef.close();
							this.versionSelected = tempVersionSelected;
							return null;
						},
					},
					{
						text: 'Delete',
						primary: true,
						action: (_evt) => {
							this._busyService.showLoading();
							return true;
						},
					},
				],
			});
			const responseDelete: any = await this.dialogRef.result.toPromise();
			const toDelete = await responseDelete.action();
			if (toDelete === null) {
				return;
			}
			this._busyService.showLoading();
			if (toDelete) {
				responseNewVersion = await this._webservices.createNewVersion({
					rateCardId: _rateCardId,
				});
			}
		}
		if (responseNewVersion && responseNewVersion.success) {
			const {
				result: { id: versionId, rateCardId: rateCardId },
			} = responseNewVersion;
			localStorage.removeItem(VERSION_ID_STRING);
			localStorage.removeItem(RATECARD_ID_STRING);
			let rateCard;

			const rateCardsResponse = await this._webservices.getRateCardsVersion(rateCardId);
			rateCard = rateCardsResponse.result;
			_.extend(rateCard, { versionInProgress: versionId });
			if (!_avoidFetch) {
				this.rateCardSelected = rateCard;
				return this.fetchRateCardsWithVersion(rateCard.id, versionId);
			} else {
				return responseNewVersion;
			}
		} else {
			return responseNewVersion;
		}
	}

	/**
	 * @method duplicateVersion
	 * Creates a new version in the given rate card and selects it
	 * Sends event for rateCards, rateCardSelected, versionSelected
	 * @param {string} _rateCardId ratecard to add a new version into
	 * @return {void}
	 */
	public async duplicateVersion(_item) {
		doLog && console.log(LOG_TAG, 'duplicateVersion', _item);
		const versionDuplicate: any = {
			id: this.versionSelected.id,
			rateCardId: this.versionSelected.rateCardId,
		};

		switch (_item.type) {
			case 'category':
				_.extend(versionDuplicate, { categories: [] });
				versionDuplicate.categories.push(_item.dataItem);
				break;
			case 'product':
				_.extend(versionDuplicate, { products: [] });
				versionDuplicate.products.push(_item.dataItem);
				break;
			case 'input':
				_.extend(versionDuplicate, { inputs: [] });
				versionDuplicate.inputs.push(_item.dataItem);
				break;
			case 'vendor':
				_.extend(versionDuplicate, { vendorCodes: [] });
				versionDuplicate.vendorCodes.push(_item.dataItem);
				break;
			case 'residual':
				_.extend(versionDuplicate, { products: [] });
				versionDuplicate.products.push(_item.dataItem);
				break;
			case 'term':
				_.extend(versionDuplicate, { terms: _item.dataItem });
				break;
			case 'batch':
				_.extend(versionDuplicate, { products: _item.dataItem.products, categories: _item.dataItem.categories });
				break;
			case 'rateProgram':
				const rateProgram = [..._item.dataItem] || [];
				_.extend(versionDuplicate, { rateProgram });
				break;
			default:
				// nothing to do
				break;
		}

		const response = await this._webservices.duplicateVersion(versionDuplicate);

		const {
			result: { id: versionId, rateCardId: rateCardId },
		} = response;

		localStorage.removeItem(VERSION_ID_STRING);
		localStorage.removeItem(RATECARD_ID_STRING);

		const rateCardsResponse = await this._webservices.getRateCardsVersion(rateCardId);

		const { result: rateCard } = rateCardsResponse;

		_.extend(rateCard, { versionInProgress: versionId });
		this.rateCardSelected = rateCard;

		const tmpRateCard = this.rateCardSelected;
		_.extend(tmpRateCard, {
			versionInProgress: versionId,
		});
		this.rateCardSelected = tmpRateCard;
		this.versionSelected = _.find(this.rateCardSelected.versions, {
			archived: false,
			published: false,
		});
		localStorage.setItem(VERSION_ID_STRING, this.versionSelected.id);
		localStorage.setItem(RATECARD_ID_STRING, this.rateCardSelected.id);
	}

	/**
	 * @method importVersion
	 * Calls API to import data into new In-Progress version from another option like: ENV + rateCard + versionId
	 * @param _versionData Contains the data to import into the new In-Progress version.
	 * @return {void}
	 */
	public async importVersion(_versionData) {
		doLog && console.log(LOG_TAG, 'importVersion', _versionData);
		localStorage.removeItem(VERSION_ID_STRING);
		localStorage.removeItem(RATECARD_ID_STRING);
		if (this.rateCardSelected.versionInProgress && this.rateCardSelected.versionInProgress !== null) {
			const tempVersionSelected = this.versionSelected;
			this._busyService.hideLoading();
			this.dialogRef = this._dialogService.open({
				title: 'Delete In-Progress Version',
				content: DeleteVersionDialogComponent,
				actions: [
					{
						text: 'Cancel',
						action: (_evt) => {
							this.dialogRef.close();
							this.versionSelected = tempVersionSelected;
							return null;
						},
					},
					{
						text: 'Delete',
						primary: true,
						action: (_evt) => {
							this._busyService.showLoading();
							return this._webservices.importFrom(_versionData);
						},
					},
				],
			});
			const response: any = await this.dialogRef.result.toPromise();
			const responseVersion = await response.action();
			if (responseVersion === null) {
				return;
			}
			if (responseVersion.success) {
				_.delay(() => {
					return this.fetchRateCardsWithVersion(responseVersion.result.rateCardId, responseVersion.result.id);
				}, 3000);
			}
			return null;
		} else {
			const response = await this._webservices.importFrom(_versionData);
			if (response.success) {
				_.delay(() => {
					return this.fetchRateCardsWithVersion(response.result.rateCardId, response.result.id);
				}, 3000);
			}
			return null;
		}
	}

	/**
	 * @method importList
	 * Retrieves all the import options to populate the prompt.
	 * @return {Object[]}
	 */
	public async importList() {
		const response = await this._webservices.getAllImportList();
		const { result: importList } = response;
		if (response.success) {
			return importList;
		}
	}

	/**
	 * @method saveInput
	 * Updates a single input, obtaining its version from its versionId property
	 * Sends event for versionSelected
	 * @param {object} _newInput input to update
	 * @return {void}
	 */
	public async saveInput(_newInput: any) {
		const input = {
			name: _newInput.name,
			type: _newInput.type,
			terms: _newInput.terms,
			versionId: this.versionSelected.id,
		};
		const versionInProgress = await this.findVersionInProgress({ dataItem: input, type: 'input' });
		doLog && console.log(LOG_TAG, 'saveInput', versionInProgress);

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;

			const response = await this._webservices.saveRateCardInput(input);
			if (response.success) {
				return response.result;
			} else {
				return response.message;
			}
		}
	}

	/**
	 * @method updateTerms
	 * Updates the terms for the current versionSelected
	 * Sends event for versionSelected
	 * @param {object} _terms terms to update
	 * @return {void}
	 */
	public async updateTerms(_terms: string[]) {
		doLog && console.log(LOG_TAG, 'updateTerms');
		if (!this.versionSelected) {
			return;
		}
		const versionInProgress = await this.findVersionInProgress({ dataItem: _terms, type: 'term' });

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const data = {
				id: versionInProgress.result.id,
				terms: _terms,
			};
			const response = await this._webservices.updateVersion(data);
			if (response.success) {
				return this.fetchRateCardsWithVersion();
			} else {
				return response.message;
			}
		}
	}

	/**
	 * @method updateTermsAndCofs
	 * Updates terms and cofs to current version
	 * @param {Object} _data receives object with version id, terms and cofs
	 * @return {Object}
	 */
	public async updateTermsAndCofs(_data) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: [], type: 'rateprogram' });
		doLog && console.log(LOG_TAG, 'updateTermsAndCofs', versionInProgress);
		if (versionInProgress === false) {
			return;
		}
		if (!versionInProgress) {
			const { id = '' } = this.versionSelected;
			_data.id = id;
		}
		const response = (await this._webservices.updateVersion(_data)) || {};
		if (response && response.success) {
			return response.result;
		}
		const { messsage = '' } = response.error || ERROR_MESSAGE;
		return messsage;
	}

	/**
	 * @method saveResidual
	 * Updates a single residual, obtaining the version to update from its versionId property
	 * Sends event for versionSelected
	 * @param {object} _newResidual input to update
	 * @return {void}
	 */
	public async saveResidual(_newResidual: any) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _newResidual, type: 'residual' });
		doLog && console.log(LOG_TAG, 'saveResidual', versionInProgress);

		const residual = {
			id: _newResidual.id,
			name: _newResidual.name,
			categoryId: _newResidual.categoryId,
			order: _newResidual.order,
			versionId: _newResidual.versionId,
			hasItad: _newResidual.hasItad,
			itadValue: _newResidual.itadValue,
			ratesEnabled: _newResidual.ratesEnabled,
			terms: _newResidual.terms,
		};
		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			residual.itadValue = this.parseItadToNumber(residual);
			const response = await this._webservices.updateProduct(residual);
			if (response.success) {
				if (response.result) {
					const tempProduct = _.find(this.versionSelected.products, { id: _newResidual.id });
					_.extend(tempProduct, { itadValue: _newResidual.itadValue });
				}
				return response.result;
			} else {
				return response.message;
			}
		}
	}

	/**
	 * @method publishVersion
	 * Publishes the given version to make it available with the mobile app
	 * Sends event for rateCardSelected, versionSelected
	 * @param {string} _rateCardId rateCard id to publish
	 * @return {Object}
	 */
	public async publishVersion(_rateCardId: string) {
		await this._webservices.publishRateCardVersion(_rateCardId);
		await this.waitForVersionPublishing(this.versionSelected.id);
		await this.fetchRateCardSelected(_rateCardId);

		localStorage.setItem(VERSION_ID_STRING, this.versionSelected.id);
		localStorage.setItem(RATECARD_ID_STRING, _rateCardId);

		return this.versionSelected.id;
	}

	/**
	 * @method waitForVersionPublishing
	 * checks for the given version and stops the flow of the code
	 * until its property `isPublishing` returns true
	 * @return {Promise<void>}
	 */
	public async waitForVersionPublishing(_versionId) {
		const isVersionPublishing = async () => {
			try {
				const response = await this._webservices.getVersion(_versionId);

				const {
					result: { isPublishing = false },
				} = response;

				return isPublishing;
			} catch (error) {
				doLog && console.error(`${LOG_TAG} - waitForVersionPublishing error - ${error.message} - ${error.stack}`);
				return true;
			}
		};

		return new Promise(async (resolve) => {
			let isPublishing = await isVersionPublishing();
			if (!isPublishing) {
				return resolve();
			}

			let waitInterval = setInterval(async () => {
				isPublishing = await isVersionPublishing();
				if (!isPublishing) {
					clearInterval(waitInterval);
					waitInterval = null;

					resolve();
				}
			}, this.intervalTime);
		});
	}

	/**
	 * @method fetchVersionSelected
	 * Fetch version selected from the combobox on nav toolbar.
	 * @return {void}
	 */
	public async fetchVersionSelected(_versionId: string) {
		const response = await this._webservices.getVersion(_versionId);
		if (response.success) {
			const { result: version } = response;
			this.versionSelected = version;
		}
	}

	/**
	 * @method fetchRateCardSelected
	 * Fetch rateCard selected from the combobox on nav toolbar.
	 * @return {void}
	 */
	public async fetchRateCardSelected(_rateCardId: string) {
		const response = await this._webservices.getRateCardsVersion(_rateCardId);
		if (response.success) {
			const { result: rateCard } = response;
			this.rateCardSelected = rateCard;
			this.versionSelected = this.findVersionSelected(null, this.rateCardSelected.versions, this.rateCardSelected);
		}
	}

	/**
	 * @method deleteVersion
	 * Deletes the given version and updates the rate card to reflect the new version in progress
	 * Sends event for rateCardSelected, versionSelected
	 * @param {string} _versionId version to delete
	 * @return {void}
	 */
	public async deleteVersion(_versionId: string, _avoidFetch = false) {
		const response = await this._webservices.deleteRateCardVersion(this.rateCardSelected.id, _versionId);
		if (response.success) {
			const { result: version } = response;
			const rateCard = this.rateCardSelected;
			localStorage.removeItem(VERSION_ID_STRING);
			localStorage.removeItem(RATECARD_ID_STRING);
			await this.fetchRateCardSelected(rateCard.id);
			localStorage.setItem(VERSION_ID_STRING, this.versionSelected.id);
			localStorage.setItem(RATECARD_ID_STRING, this.rateCardSelected.id);
		}
	}

	/**
	 * @method createCategory
	 * Adds a product category to the catalogue of the version selected.
	 * @param {Object} _category Category data to add to the catalogue.
	 * @return {Object | String}
	 */
	public async createCategory(_category: any) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _category, type: 'category' });
		doLog && console.log(LOG_TAG, 'createCategory', versionInProgress);

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;
			const response = await this._webservices.createCategory(_category);
			doLog && console.debug(`${LOG_TAG} - createCategory - ${response}`);
			const versionSelected = version;
			const categoriesList = version.categories || [];
			if (response.success) {
				categoriesList.push(response.result);
				_.extend(versionSelected, { categories: categoriesList });
				this.versionSelected = versionSelected;
				return response.result;
			} else {
				return response;
			}
		}
	}

	/**
	 * @method createProduct
	 * Adds a product to the catalogue of the version selected.
	 * @param {Object} _product Product data to add to the catalogue.
	 * @return {Object | String}
	 */
	public async createProduct(_product: any) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _product, type: 'product' });
		doLog && console.log(LOG_TAG, 'createProduct', versionInProgress);

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;
			const response = await this._webservices.createProduct(_product);
			doLog && console.debug(`${LOG_TAG} - createProduct - ${response}`);
			const versionSelected = version;
			const productList = version.products || [];
			if (response.success) {
				productList.push(response.result);
				_.extend(versionSelected, { products: productList });
				this.versionSelected = versionSelected;
				return response.result;
			} else {
				return response;
			}
		}
	}

	/**
	 * @method removeCategory
	 * Removes a product category from the catalogue of the version selected.
	 * @param {Object} _category Category data to remove from the catalogue.
	 * @return {void}
	 */
	public async removeCategory(_category: any) {
		_.extend(_category, { deleted: true });
		const versionInProgress = await this.findVersionInProgress({ dataItem: _category, type: 'category' });
		doLog && console.log(LOG_TAG, 'removeCategory', versionInProgress);

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;

			_.extend(_category, { deleted: false });
			try {
				return await this._webservices.deleteCategory(_category.id, _category.versionId);
			} catch (_error) {
				doLog && console.debug(`${LOG_TAG} - removeCategory - ${_error}`);
				return null;
			}
		}
	}

	/**
	 * @method removeProduct
	 * Removes a product from the catalogue of the version selected.
	 * @param {Object} _product Product data to remove from the catalogue.
	 * @return {void}
	 */
	public async removeProduct(_product: any) {
		_.extend(_product, { deleted: true });
		doLog && console.log(LOG_TAG, 'removeProduct', _product);

		const versionInProgress = await this.findVersionInProgress({ dataItem: _product, type: 'product' });
		doLog && console.log(LOG_TAG, 'removeProduct', versionInProgress);

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;

			_.extend(_product, { deleted: false });
			try {
				const response = this._webservices.deleteProduct(_product.id, _product.versionId);
				return response;
			} catch (_error) {
				doLog && console.debug(`${LOG_TAG} - removeCategory - ${_error}`);
				return null;
			}
		}
	}

	/**
	 * @method updateCategory
	 * Updates a category from the catalogue of the version selected.
	 * @param {Object} _category Category data to update from the catalogue.
	 * @return {Object | String}
	 */
	public async updateCategory(_category: any) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _category, type: 'category' });
		doLog && console.log(LOG_TAG, 'updateCategory', versionInProgress);
		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;
			const response = await this._webservices.updateCategory(_category);
			if (response.success) {
				return response.result;
			}
			return response.message;
		}
	}

	/**
	 * @method updateProduct
	 * Updates a product from the catalogue of the version selected.
	 * @param {Object} _product Product data to update from the catalogue.
	 * @return {Object | String}
	 */
	public async updateProduct(_product: any) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _product, type: 'product' });
		doLog && console.log(LOG_TAG, 'updateProduct', versionInProgress);

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;
			_product.itadValue = this.parseItadToNumber(_product);
			const response = await this._webservices.updateProduct(_product);
			if (response.success) {
				return response.result;
			}
			return response.message;
		}
	}

	/**
	 * @method batchProductsCategoriesUpdate
	 * Calls a batch update request to update all the categories and products from catalogue into database.
	 * This call is required to store all the sort order values customized by the user.
	 * @param {Object} _productsCategories Stores all the catalogue (products and categories) data of the current version selected.
	 * @return {Boolean}
	 */
	public async batchProductsCategoriesUpdate(_productsCategories) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _productsCategories, type: 'batch' });
		doLog && console.log(LOG_TAG, 'updateProduct', versionInProgress);

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const response = await Promise.all([
				this._webservices.batchUpdate('product', this.versionSelected.id, _productsCategories.products),
				this._webservices.batchUpdate('category', this.versionSelected.id, _productsCategories.categories),
			]);
			if (response.every((res) => res.success === true)) {
				this.fetchRateCardsWithVersion(this.rateCardSelected.id, this.versionSelected.id);
				return true;
			}
			return false;
		}
	}

	/**
	 * @method createRateCard
	 * Calls API Request to create a new rateCard.
	 * @param {object} _rateCard The ratecard data to create.
	 * @return {object}
	 */
	public async createRateCard(_rateCard) {
		const response = await this._webservices.createRateCard(_rateCard);
		doLog && console.log(LOG_TAG, 'createRateCard', response);
		if (response.success) {
			return response.result;
		} else {
			return response;
		}
	}

	/**
	 * @method updateRateCard
	 * Calls API Request to update a rateCard.
	 * @param {object} _rateCard The rateCard data to update.
	 * @return {object}
	 */
	public async updateRateCard(_rateCard) {
		const response = await this._webservices.updateRateCard(_rateCard);
		doLog && console.log(LOG_TAG, 'updateRateCard', response);
		if (response.success) {
			return response.result;
		} else {
			return response;
		}
	}

	/**
	 * @method deleteRateCard
	 * Calls API Request to delete a rateCard.
	 * @param {object} _rateCardId The rateCardId to remove.
	 * @return {object}
	 */
	public async deleteRateCard(_rateCardId) {
		try {
			await this._webservices.deleteRateCard(_rateCardId);
		} catch (_error) {
			doLog && console.debug(`${LOG_TAG} - deleteRateCard - ${_error}`);
			return null;
		}
	}

	/**
	 * @method duplicateVersionFromVendor
	 * Duplicates publish version and populate new results for vendors.s
	 * @return {void}
	 */
	private async duplicateVersionFromVendor(_item, _rateCardId, _versionId) {
		const versionDuplicate: any = {
			id: _versionId,
			rateCardId: _rateCardId,
		};
		_.extend(versionDuplicate, { vendorCodes: [] });
		versionDuplicate.vendorCodes.push(_item);
		localStorage.removeItem(VERSION_ID_STRING);
		localStorage.removeItem(RATECARD_ID_STRING);
		return this._webservices.duplicateVersion(versionDuplicate);
	}

	/**
	 * @method createVendorCode
	 * Calls API Request to create a new vendorCode.
	 * @param {object} _vendorCode The vendorCode data to create.
	 * @return {object}
	 */
	public async createVendorCode(_vendorCode, _rateCard) {
		doLog && console.log(`${LOG_TAG} - createVendorCode`, _vendorCode);
		if (_rateCard.versionInProgress) {
			const result = await this._webservices.createVendorCode(_vendorCode);
			return result.result;
		} else {
			const versionInProgress = await this.duplicateVersionFromVendor(_vendorCode, _rateCard.id, _rateCard.versionPublished);
			doLog && console.log(`${LOG_TAG} - duplicateVersionFromVendor - create`, versionInProgress);
			if (versionInProgress.success) {
				const { result: version } = versionInProgress;
				_.extend(_rateCard, {
					vendorCodes: version.vendorCodes,
					versionInProgress: version.id,
				});
				localStorage.setItem(VERSION_ID_STRING, version.id);
				return _rateCard;
			}
		}
	}

	/**
	 * @method updateVendorCode
	 * Calls API Request to update a vendorCode.
	 * @param {object} _vendorCode The vendorCode data to update.
	 * @return {object}
	 */
	public async updateVendorCode(_vendorCode, _rateCard) {
		if (_rateCard.versionInProgress) {
			const result = await this._webservices.updateVendorCode(_vendorCode);
			return result.result;
		}
		const versionInProgress = await this.duplicateVersionFromVendor(_vendorCode, _rateCard.id, _rateCard.versionPublished);
		doLog && console.log(`${LOG_TAG} - duplicateVersionFromVendor - update`, versionInProgress);
		if (versionInProgress.success) {
			const { result: version } = versionInProgress;
			_.extend(_rateCard, {
				vendorCodes: version.vendorCodes,
				versionInProgress: version.id,
			});
			localStorage.setItem(VERSION_ID_STRING, version.id);
			return _rateCard;
		}
	}

	/**
	 * @method deleteVendorCode
	 * Calls API Request to delete a rateCard.
	 * @param {string} _vendorCodeId The _vendorCodeId to remove.
	 * @param {string} _rateCardId The rateCardId where vendor code belongs
	 * @return {void}
	 */
	public async deleteVendorCode(_vendorCode) {
		const rateCard = _vendorCode.rateCard;
		const vendorCode = {
			id: _vendorCode.id,
			deleted: true,
			rateCardId: rateCard.id,
		};

		if (!_vendorCode.rateCard.versionInProgress) {
			const versionInProgress = await this.duplicateVersionFromVendor(vendorCode, rateCard.id, rateCard.versionPublished);
			doLog && console.log(`${LOG_TAG} - duplicateVersionFromVendor - delete`, versionInProgress);
			if (versionInProgress.success) {
				const { result: version } = versionInProgress;
				_.extend(rateCard, {
					vendorCodes: version.vendorCodes,
					versionInProgress: version.id,
				});
				localStorage.setItem(VERSION_ID_STRING, version.id);
				return rateCard;
			}
		}
		try {
			await this._webservices.deleteVendorCode(vendorCode.id, vendorCode.rateCardId);
		} catch (_error) {
			doLog && console.debug(`${LOG_TAG} - deleteVendorCode - ${_error}`);
			return null;
		}
	}

	/**
	 * @method listAllRateCardsAndVendors
	 * Retrieve all the ratecards and vendors list to populate module.
	 * @return {object | boolean}
	 */
	public async listAllRateCardsAndVendors() {
		doLog && console.log(`${LOG_TAG} - listAllRateCardsAndVendors`);

		const rateCardsAndVendorsList = await this._webservices.getAllRateCardsWithVendors();
		if (rateCardsAndVendorsList.success) {
			rateCardsAndVendorsList.result = _.filter(rateCardsAndVendorsList.result, (_rateCard) => {
				return _rateCard.id !== null && !_rateCard.deleted;
			});

			return rateCardsAndVendorsList.result;
		}
	}

	/**
	 * @method exportVersion
	 * Exports version selected into a csv file.
	 * @param {string} _versionId versionId to export.
	 * @param {Object} _vendorName vendor code name chosen to export.
	 * @return {void}
	 */
	public async exportVersion(_versionId, _vendorName) {
		this._busyService.setLoaderMessage('Please wait. The version is being exported.');
		const response = await this._webservices.exportVersion(_versionId, _vendorName);
		this._busyService.setLoaderMessage('Loading...');
		if (response.size && response.size > 0) {
			return response;
		} else {
			return response.message;
		}
	}

	/**
	 * @method exportAuditLogs
	 * Exports Audit Logs filtered into a csv file.
	 * @return {void}
	 */
	public async exportAuditLogs() {
		this._busyService.setLoaderMessage('Please wait. Audit log is being exported.');
		const response = await this._webservices.exportAuditLogs();
		this._busyService.setLoaderMessage('Loading...');
		if (response.size && response.size > 0) {
			return response;
		} else {
			return response.message;
		}
	}

	/**
	 * @method recalculateFactors
	 *  Call API to recalculate ratefactors table and display on grid.
	 * @param {Object} _rateCardData The current ratecard data to calculate.
	 * @returns {object}
	 */
	public async recalculateFactors(_rateCardData, _vendor) {
		const response = await this._webservices.calculateFactors(_rateCardData.versionInProgress, _vendor);
		if (!response.success) {
			return response;
		}

		let { result: rateFactors } = response;

		if (_.size(rateFactors) === 0) {
			rateFactors = { fmv: [], out: [] };
		}

		rateFactors = this.formatRateFactors(rateFactors);

		return rateFactors;
	}

	/**
	 * @method recalculateFactorsOthc
	 * Call API to recalculate ratefactors table and display on grid.
	 * @param {Object} _data The current rate programs data to calculate.
	 * @returns {object}
	 */
	public async recalculateFactorsOthc(_data) {
		const response = await this._webservices.calculateFactorsOtch(_data);
		if (!response.success) {
			return response;
		}
		const { result: rateFactors } = response;

		// TODO: add format to rate Factors for OTHC
		// rateFactors = this.formatRateFactors(rateFactors);

		return rateFactors;
	}

	/**
	 * @method compareVersions
	 *  Call API to compare Versions.
	 * @param {Object} _versionId The current version.
	 * @param {Object}  _versionToCompare The version to compare.
	 * @returns {object}
	 */
	public async compareVersions(_compareData) {
		const response = await this._webservices.compareVersion(_compareData.versionId, _compareData.versionToCompare);
		if (response.success) {
			const tempVersionSelected = this.versionSelected;
			const rmv = [];
			const out = [];
			_.forEach(response.result.items, (value) => {
				if (value.product !== null) {
					rmv.push(value);
				} else {
					out.push(value);
				}
			});
			_.extend(tempVersionSelected, {
				comparedData: {
					terms: response.result.terms,
					items: { rmv, out },
					versionCurrentName: _compareData.versionCurrentName,
					versionSelectedName: _compareData.versionSelectedName,
				},
			});
			this.versionSelected = tempVersionSelected;
			return response.result;
		} else {
			return response;
		}
	}

	/**
	 * @method getRateFactors
	 *  Call API to recalculate ratefactors table and display on grid.
	 * @param {Object} _versionData The current ratecard data to calculate.
	 * @returns {object}
	 */
	public async getRateFactors(_versionData, _vendorCode) {
		const _rateFactorsResponse = await this._webservices.getRateFactorsTable(_versionData, _vendorCode);
		if (!_rateFactorsResponse.success) {
			return _rateFactorsResponse.message;
		}

		let { result: rateFactors } = _rateFactorsResponse;

		if (_.size(rateFactors) === 0) {
			rateFactors = {
				fmv: [],
				out: [],
			};
		}

		rateFactors = this.formatRateFactors(rateFactors);

		const versionSelected = this.versionSelected;
		_.extend(versionSelected, { rateFactors });
		this.versionSelected = versionSelected;
		return rateFactors;
	}

	/**
	 * @method duplicateRateProgram
	 * Creates a new rateProgram in the given version and rate program id
	 * @param {IRateProgram} _rateProgram rateProgram to duplicate
	 * @return {promise}
	 */
	public async duplicateRateProgram(_rateProgram: IRateProgram) {
		const { versionId = '', id = '' } = _rateProgram || {};
		const rateProgramDuplicate: any = {
			versionId,
			id,
		};
		const rateProgramSelected = await this.getRateProgram(rateProgramDuplicate);
		const versionInProgress = await this.findVersionInProgress({ dataItem: [], type: 'rateProgram' });
		doLog && console.log(LOG_TAG, 'duplicateRateProgram', versionInProgress);
		if (versionInProgress === false) {
			return;
		}
		if (!versionInProgress) {
			const { name: nameRateProgram = '' } = rateProgramSelected || {};
			const { ratePrograms = [] } = this.versionSelected || {};
			const rateProgram = _.find(ratePrograms || [], { name: nameRateProgram });
			rateProgramDuplicate.versionId = rateProgram.versionId;
			rateProgramDuplicate.id = rateProgram.id;
		}
		const response = await this._webservices.duplicateRateProgram(rateProgramDuplicate);
		if (response.success) {
			return response.result;
		}
		const { message = '' } = response.error || ERROR_MESSAGE;
		return message;
	}

	/**
	 * @method deleteRateProgram
	 * Sends the request to remove the rate program from the database.
	 * @param {IRateProgram} _rateProgram rateProgram to delete
	 * @return {promise}
	 */
	public async deleteRateProgram(_rateProgram: IRateProgram) {
		_rateProgram.deleted = true;
		const versionInProgress = await this.findVersionInProgress({ dataItem: _rateProgram, type: 'rateProgram' });
		doLog && console.log(LOG_TAG, 'deleteRateProgram', versionInProgress);
		if (versionInProgress === false) {
			return;
		}
		if (!versionInProgress) {
			return {
				result: DUPLICATE_TEXT,
			};
		}
		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const rateProgramDelete = {
				versionId: _rateProgram.versionId,
				id: _rateProgram.id,
			};
			return this._webservices.deleteRateProgram(rateProgramDelete);
		}
	}

	/**
	 * @method formatRateFactors
	 * Format ratefactors results adding product name and category name.
	 * @return {Object[]}
	 */
	private formatRateFactors(_rateFactors) {
		_.chain(_rateFactors)
			.map((_rateFactor) => {
				return _.map(_rateFactor, (_rate) => {
					if (_rate.product && _rate.category && _rate.rate === 'fmv') {
						return _.extend(_rate, { name: _rate.product.name, categoryName: _rate.category.name });
					} else {
						return _rate;
					}
				});
			})
			.flattenDepth()
			.groupBy('rate')
			.value();

		return _rateFactors;
	}

	/**
	 * @method findVersionSelected
	 * Try differents attempts to find the versionSelected in the versions catalogue.
	 * @private
	 * @param {string} _versionId The version Id to find in the catalogue.
	 * @param {object[]} _versions The versions list to query to find the version Selected.
	 * @param {object} _rateCardSelected The ratecard selected.
	 * @return {object}
	 */
	private findVersionSelected(_versionId, _versions, _rateCardSelected) {
		doLog && console.log(LOG_TAG, 'findVersionSelected', _versions, _rateCardSelected, _versionId);
		if (_versionId && _.find(_versions, { id: _versionId })) {
			const version = _.find(_versions, { id: _versionId });
			return _.find(_versions, { id: _versionId });
		}
		if (_rateCardSelected.versionInProgress && _.find(_versions, { id: _rateCardSelected.versionInProgress })) {
			const version = _.find(_versions, { id: _rateCardSelected.versionInProgress });
			return _.find(_versions, { id: _rateCardSelected.versionInProgress });
		}
		if (_.find(_versions, { id: _rateCardSelected.versionPublished })) {
			const version = _.find(_versions, { id: _rateCardSelected.versionPublished });
			return _.find(_versions, { id: _rateCardSelected.versionPublished });
		}
		return null;
	}

	/**
	 * @method findRateCardSelected
	 * Try differents attempts to find the findRateCardSelected in the rateCards catalogue.
	 * @param {object[]} _rateCards The versions list to query to find the version Selected.
	 * @param {string} _rateCardId The version Id to find in the catalogue.
	 * @return {Object}
	 */
	private findRateCardSelected(_rateCards, _rateCardId) {
		doLog && console.log(LOG_TAG, 'findRateCardSelected', _rateCards, _rateCardId);
		if (_.find(_rateCards, { id: _rateCardId })) {
			return _.find(_rateCards, { id: _rateCardId });
		}
		if (
			_.find(_rateCards, (_rateCard) => {
				return _rateCard.id !== null && !_rateCard.deleted;
			})
		) {
			return _.find(_rateCards, (_rateCard) => {
				return _rateCard.id !== null && !_rateCard.deleted;
			});
		}
		return {};
	}

	/**
	 * @method findVersionInProgress
	 * Prevent any edition until version In Progress be present on rateCard.
	 * Replace / Duplicate current or read only version when user tries to edit.
	 * @return {void}
	 */
	private async findVersionInProgress(_item) {
		doLog && console.log(LOG_TAG, 'findVersionInProgress', this.versionSelected, this.rateCardSelected);
		if (this.inProgressAndDuplicateValidation() === true) {
			this._busyService.hideLoading();
			this.dialogRef = this._dialogService.open({
				title: 'Delete In-Progress Version',
				content: DeleteVersionDialogComponent,
				actions: [
					{
						text: 'Cancel',
						action: async (_evt) => {
							this.dialogRef.close();
							this._busyService.showLoading();
							await this.fetchVersionSelected(this.versionSelected.id);
							return null;
						},
					},
					{
						text: 'Delete',
						primary: true,
						action: (_evt) => {
							this._busyService.showLoading();
							return this.duplicateVersion(_item);
						},
					},
				],
			});
			const response: any = await this.dialogRef.result.toPromise();
			const responseVersion = await response.action();
			if (responseVersion === null) {
				return false;
			}

			return responseVersion;
		}

		if (this.noInProgressDuplicateValidation() === true) {
			this._busyService.showLoading();
			const responseVersion: any = await this.duplicateVersion(_item);
			return responseVersion;
		}

		return {
			duplicate: false,
			success: true,
			result: this.versionSelected,
		};
	}

	/**
	 * @method inProgressAndDuplicateValidation
	 * Validates if there is InProgress version and is different to the version Selected to edit.
	 * @private
	 * @return {boolean}
	 */
	private inProgressAndDuplicateValidation() {
		if (
			this.rateCardSelected.versionInProgress &&
			this.rateCardSelected.versionInProgress !== null &&
			this.rateCardSelected.versionInProgress !== this.versionSelected.id
		) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * @method inProgressAndDuplicateValidation
	 * Validates if there is not InProgress version and Publish or Archive version  is selected to edit.
	 * @private
	 * @return {boolean}
	 */
	private noInProgressDuplicateValidation() {
		if (
			(this.rateCardSelected.versionPublished && this.versionSelected.id === this.rateCardSelected.versionPublished) ||
			(!this.rateCardSelected.versionInProgress && this.rateCardSelected.versionInProgress !== this.versionSelected.id)
		) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * @method parseItadToNumber
	 * Return a numeric representation for a product's itad value.
	 * @param {Object} _product An object representation for a product item.
	 * @return {Number}
	 */
	private parseItadToNumber(_product: any) {
		if (_product && _product.itadValue) {
			return !_.isNumber(_product.itadValue) ? this._numberHelper.parseToNumber(_product.itadValue) : _product.itadValue;
		} else {
			return 0;
		}
	}

	/**
	 * @method reorderRatePrograms
	 * Return true if is success the reorder rate programs
	 * @param {IRateProgram[]} _ratePrograms Receives rate programs id for order
	 * @return {Promise}
	 */
	public async reorderRatePrograms(_ratePrograms: IRateProgram[]): Promise<boolean> {
		let rateProgramsIds: IReorderRatePrograms;
		const versionInProgress = await this.findVersionInProgress({ dataItem: [], type: 'rateProgram' });
		doLog && console.log(LOG_TAG, 'reorderRatePrograms', versionInProgress);
		if (versionInProgress === false) {
			return;
		}
		if (!versionInProgress) {
			const newRatePrograms = [];
			const { ratePrograms = [] } = this.versionSelected || {};
			_.forEach(_ratePrograms, (_rate) => newRatePrograms.push(_.find(ratePrograms, { name: _rate.name })));
			rateProgramsIds = this.getRateprogramsIds(newRatePrograms);
		}
		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			rateProgramsIds = this.getRateprogramsIds(_ratePrograms);
		}
		const response = await this._webservices.reorderRatePrograms(rateProgramsIds);
		if (response.success) {
			return response.result;
		}
		const { message = '' } = response.error || ERROR_MESSAGE;
		return message;
	}

	/**
	 * @method getRateprogramsIds
	 * Return rateprograms ids and version id for search in function  reorderRatePrograms
	 * @param {IRateProgram[]} _dataRatePrograms receives array with rate programs
	 * @return {IReorderRatePrograms}
	 */
	private getRateprogramsIds(_dataRatePrograms: IRateProgram[]): IReorderRatePrograms {
		const { id: versionId = '' } = this.versionSelected || {};
		const ratePrograms = _.map(_dataRatePrograms || [], (_item) => _item.id);
		return {
			ratePrograms,
			versionId,
		};
	}

	/**
	 * @method fetchRatePrograms
	 * Return rate programs list
	 * @param {string} _versionId Receives version ID
	 * @return {Promise}
	 */
	public async fetchRatePrograms(_versionId: string): Promise<IRateProgram[]> {
		const response = await this._webservices.loadRatePrograms(_versionId);
		if (response.success) {
			const { result: ratePrograms } = response;
			return ratePrograms;
		}
	}

	/**
	 * @method getRateProgram
	 * Return rate program selected by rateprogram id.
	 * @param {string}_rateProgram Receives rateProgram Id and versionId
	 * @return {Promise}
	 */
	public async getRateProgram(_rateProgram): Promise<IRateProgram> {
		const response = await this._webservices.getRateProgram(_rateProgram);
		if (response && response.success) {
			const { result: rateProgram } = response;
			return rateProgram;
		}
	}

	/**
	 * @method createNewRateProgram
	 * Create a new Rate Program
	 * @param {object} _rateProgram Recives rate program data
	 * @return {Promise}
	 */
	public async createNewRateProgram(_rateProgram: IRateProgram) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _rateProgram, type: 'rateProgram' });
		doLog && console.log(LOG_TAG, 'createNewRateProgram', versionInProgress);

		if (!versionInProgress) {
			return {
				id: DUPLICATE_TEXT,
			};
		}

		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const { result: version } = versionInProgress;
			const response = await this._webservices.createRateProgram(_rateProgram);
			doLog && console.debug(`${LOG_TAG} - createNewRateProgram - ${response}`);
			const versionSelected = version;
			const rateProgramsList = version.rateProgram || [];
			if (response && response.success) {
				const { result: rateProgram } = response;
				rateProgramsList.push(rateProgram);
				_.extend(versionSelected, { rateProgram: rateProgramsList });
				this.versionSelected = versionSelected;
				return rateProgram;
			} else {
				const { message = '' } = response.error || ERROR_MESSAGE;
				return message;
			}
		}
	}

	/**
	 * @method updateRateProgram
	 * Upates the Rate Program
	 * @param {object} _rateProgram Recives rate program data
	 * @return {Promise}
	 */
	public async updateRateProgram(_rateProgram: IRateProgram) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: _rateProgram, type: 'rateProgram' });
		doLog && console.log(LOG_TAG, 'updateRateProgram', versionInProgress);
		if (!versionInProgress) {
			return _rateProgram;
		}
		if (versionInProgress && versionInProgress.success && !versionInProgress.duplicate) {
			const response = await this._webservices.updateRateProgram(_rateProgram);
			if (response && response.success) {
				const { result: rateProgram } = response;
				return rateProgram;
			} else {
				const { message = '' } = response.error || ERROR_MESSAGE;
				return message;
			}
		}
	}

	/**
	 * @method saveRateProgramInput
	 * Upates the Rate Program input data
	 * @param {object} _rateProgramInput Recives rate program input data
	 * @param {IRateProgram} _rateProgram receives rate program data
	 * @return {Promise}
	 */
	public async saveRateProgramInput(_rateProgramInput, _rateProgram: IRateProgram) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: [], type: 'rateProgram' });
		let versionDuplicate = false;
		doLog && console.log(LOG_TAG, 'saveRateProgramInput', versionInProgress);
		if (versionInProgress === false) {
			return;
		}
		if (!versionInProgress) {
			const { id = '', ratePrograms = [] } = this.versionSelected;
			const rateProgram = _.find(ratePrograms, { name: _rateProgram.name });
			_rateProgramInput.versionId = id;
			_rateProgramInput.rateProgramId = rateProgram.id;
			versionDuplicate = true;
		}
		const response = await this._webservices.saveRateProgramInput(_rateProgramInput);
		if (response.success) {
			_.extend(response.result, { versionDuplicate });
			return response.result;
		}
	}

	/**
	 * @method saveResidualsRateProgramInput
	 * Upates residuals in rate cards input othc
	 * @param {object} _data Recives rate program input data
	 * @param {IRateProgram} _rateProgram receives rate program data
	 * @return {Promise}
	 */
	public async saveResidualsRateProgramInput(_data, _rateProgram: IRateProgram) {
		const versionInProgress = await this.findVersionInProgress({ dataItem: [], type: 'rateProgram' });
		let versionDuplicate = false;
		doLog && console.log(LOG_TAG, 'saveResidualsRateProgramInput', versionInProgress);
		if (versionInProgress === false) {
			return;
		}
		if (!versionInProgress) {
			const { id = '', ratePrograms = [] } = this.versionSelected;
			const rateProgram = _.find(ratePrograms, { name: _rateProgram.name });
			_data.versionId = id;
			_data.rateProgramId = rateProgram.id;
			versionDuplicate = true;
		}
		const response = await this._webservices.saveResidualsRateProgramInput(_data);
		if (response.success) {
			_.extend(response.result, { versionDuplicate });
			return response.result;
		}
	}
}
